<!DOCTYPE html>
<html lang="English">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.67">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>Programer's Lifes</title><meta name="description" content="Do not regret for wasting time, do not be ashamed of mediocrity.">
    <link rel="preload" href="/my-vuepress-blog/assets/style-e1f21a1f.css" as="style"><link rel="stylesheet" href="/my-vuepress-blog/assets/style-e1f21a1f.css">
    <link rel="modulepreload" href="/my-vuepress-blog/assets/app-521e935c.js"><link rel="modulepreload" href="/my-vuepress-blog/assets/Operating System.html-ff9c155d.js"><link rel="modulepreload" href="/my-vuepress-blog/assets/Operating System.html-a5cd54a3.js"><link rel="prefetch" href="/my-vuepress-blog/assets/index.html-8e536b67.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/index.html-cd51371e.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/CPP.html-85224617.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/C语言.html-de2179da.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/Docker.html-62f3fcc4.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/Echarts图表基本结构.html-bf5748db.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/Electron SerialPort.html-863de4b2.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/GNU.html-9b334f8b.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/Git.html-41292ae1.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/Kernel.html-354884f3.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/Linux.html-41b6034c.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/Makefile.html-1e542293.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/MongoDB.html-ea01f80f.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/OpenCV.html-6049be6f.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/index.html-6e375392.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/STM32.html-d97e1897.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/Spring Cloud.html-8e5485e0.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/TensorFlow.html-f60d479b.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/乱七八糟.html-dbb41269.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/数据结构与算法C语言实现.html-bc59e5ee.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/CPP.html-d038ca97.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/C语言.html-a6627571.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/Docker.html-a77869ee.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/Echarts图表基本结构.html-0e2beb2a.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/Electron SerialPort.html-fe4120f2.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/Git.html-e0ab504c.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/Kernel.html-af1902df.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/Linux.html-07b89f5b.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/Makefile.html-26496d14.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/MongoDB.html-c29783f5.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/OpenCV.html-57ad1333.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/Operating System.html-c9dbe43a.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/index.html-3b67e3e3.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/STM32.html-2411d764.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/Spring Cloud.html-a6fa84ba.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/TensorFlow.html-805d6d17.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/乱七八糟.html-8f83464a.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/数据结构与算法C语言实现.html-ea7eb110.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/ 计算机底层原理及电路实现.html-39718876.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/ 计算机底层原理及电路实现.html-c7f5783a.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/404.html-f62106ff.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/index.html-0e3add3d.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/index.html-2979ca24.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/CPP.html-c6fc80dc.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/C语言.html-ae8f0269.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/Docker.html-394e9cca.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/Echarts图表基本结构.html-8e47e651.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/Electron SerialPort.html-38348bb5.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/GNU.html-87241cdd.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/Git.html-1f1d16cc.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/Kernel.html-ca601a94.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/Linux.html-216564d1.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/Makefile.html-ebdd7b52.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/MongoDB.html-85c33282.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/OpenCV.html-7ef34afa.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/index.html-a62301c6.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/STM32.html-f2370b0b.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/Spring Cloud.html-743dec54.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/TensorFlow.html-b958c422.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/乱七八糟.html-fff02bd4.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/数据结构与算法C语言实现.html-ccd7c332.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/CPP.html-0353cc68.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/C语言.html-faa4c062.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/Docker.html-caf4f3ca.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/Echarts图表基本结构.html-d660b06b.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/Electron SerialPort.html-6807c7c7.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/Git.html-fd0cd085.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/Kernel.html-d52b7005.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/Linux.html-99acd2c6.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/Makefile.html-28e441bf.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/MongoDB.html-c26c3399.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/OpenCV.html-b0ba95bc.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/Operating System.html-ca4c11eb.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/index.html-387a8185.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/STM32.html-39688344.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/Spring Cloud.html-69259a35.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/TensorFlow.html-5134a5c2.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/乱七八糟.html-403523ab.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/数据结构与算法C语言实现.html-5dcda878.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/ 计算机底层原理及电路实现.html-51b5a534.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/ 计算机底层原理及电路实现.html-2e5c188b.js" as="script"><link rel="prefetch" href="/my-vuepress-blog/assets/404.html-9e190cf3.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/my-vuepress-blog/" class=""><!----><span class="site-name can-hide">Programer&#39;s Lifes</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/my-vuepress-blog/" class="" aria-label="Home"><!--[--><!--]--> Home <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Note"><span class="title">Note</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Note"><span class="title">Note</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/README.md" class="" aria-label="Designed Pattern"><!--[--><!--]--> Designed Pattern <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/C语言.md" class="" aria-label="C Language"><!--[--><!--]--> C Language <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/CPP.md" class="" aria-label="C Plus Plus"><!--[--><!--]--> C Plus Plus <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/Docker.md" class="" aria-label="Docker"><!--[--><!--]--> Docker <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/Echarts图表基本结构.md" class="" aria-label="Echarts Basic Structure"><!--[--><!--]--> Echarts Basic Structure <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/Git.md" class="" aria-label="Git"><!--[--><!--]--> Git <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/Linux.md" class="" aria-label="Linux"><!--[--><!--]--> Linux <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/Makefile.md" class="" aria-label="Makefile"><!--[--><!--]--> Makefile <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/MongoDB.md" class="" aria-label="MongoDB"><!--[--><!--]--> MongoDB <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/OpenCV.md" class="" aria-label="OpenCV"><!--[--><!--]--> OpenCV <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/Operating System.md" class="" aria-label="Operating System"><!--[--><!--]--> Operating System <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/Spring Cloud.md" class="" aria-label="Spring Cloud"><!--[--><!--]--> Spring Cloud <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/STM32.md" class="" aria-label="STM32"><!--[--><!--]--> STM32 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/TensorFlow.md" class="" aria-label="TensorFlow"><!--[--><!--]--> TensorFlow <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/乱七八糟.md" class="" aria-label="Mix"><!--[--><!--]--> Mix <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/数据结构与算法C语言实现.md" class="" aria-label="Data Structure and Algorithm"><!--[--><!--]--> Data Structure and Algorithm <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Kernel"><span class="title">Kernel</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Kernel"><span class="title">Kernel</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/Kernel.md" class="" aria-label="Kernel"><!--[--><!--]--> Kernel <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/GNU.md" class="" aria-label="GNU"><!--[--><!--]--> GNU <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Select language"><span class="title">Languages</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Select language"><span class="title">Languages</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html" class="router-link-active router-link-exact-active router-link-active" aria-label="English"><!--[--><!--]--> English <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/zh/note/Operating%20System.html" class="" aria-label="简体中文"><!--[--><!--]--> 简体中文 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/GerryDush" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" placeholder="Search" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/my-vuepress-blog/" class="" aria-label="Home"><!--[--><!--]--> Home <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Note"><span class="title">Note</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Note"><span class="title">Note</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/README.md" class="" aria-label="Designed Pattern"><!--[--><!--]--> Designed Pattern <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/C语言.md" class="" aria-label="C Language"><!--[--><!--]--> C Language <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/CPP.md" class="" aria-label="C Plus Plus"><!--[--><!--]--> C Plus Plus <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/Docker.md" class="" aria-label="Docker"><!--[--><!--]--> Docker <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/Echarts图表基本结构.md" class="" aria-label="Echarts Basic Structure"><!--[--><!--]--> Echarts Basic Structure <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/Git.md" class="" aria-label="Git"><!--[--><!--]--> Git <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/Linux.md" class="" aria-label="Linux"><!--[--><!--]--> Linux <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/Makefile.md" class="" aria-label="Makefile"><!--[--><!--]--> Makefile <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/MongoDB.md" class="" aria-label="MongoDB"><!--[--><!--]--> MongoDB <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/OpenCV.md" class="" aria-label="OpenCV"><!--[--><!--]--> OpenCV <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/Operating System.md" class="" aria-label="Operating System"><!--[--><!--]--> Operating System <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/Spring Cloud.md" class="" aria-label="Spring Cloud"><!--[--><!--]--> Spring Cloud <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/STM32.md" class="" aria-label="STM32"><!--[--><!--]--> STM32 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/TensorFlow.md" class="" aria-label="TensorFlow"><!--[--><!--]--> TensorFlow <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/乱七八糟.md" class="" aria-label="Mix"><!--[--><!--]--> Mix <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/数据结构与算法C语言实现.md" class="" aria-label="Data Structure and Algorithm"><!--[--><!--]--> Data Structure and Algorithm <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Kernel"><span class="title">Kernel</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Kernel"><span class="title">Kernel</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/Kernel.md" class="" aria-label="Kernel"><!--[--><!--]--> Kernel <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/note/GNU.md" class="" aria-label="GNU"><!--[--><!--]--> GNU <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="Select language"><span class="title">Languages</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="Select language"><span class="title">Languages</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html" class="router-link-active router-link-exact-active router-link-active" aria-label="English"><!--[--><!--]--> English <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/my-vuepress-blog/zh/note/Operating%20System.html" class="" aria-label="简体中文"><!--[--><!--]--> 简体中文 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/GerryDush" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading"> <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#计算机底层原理及电路实现" class="router-link-active router-link-exact-active sidebar-item" aria-label="计算机底层原理及电路实现"><!--[--><!--]--> 计算机底层原理及电路实现 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#进制转换" class="router-link-active router-link-exact-active sidebar-item" aria-label="进制转换"><!--[--><!--]--> 进制转换 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#真值表" class="router-link-active router-link-exact-active sidebar-item" aria-label="真值表"><!--[--><!--]--> 真值表 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#逻辑门电路" class="router-link-active router-link-exact-active sidebar-item" aria-label="逻辑门电路"><!--[--><!--]--> 逻辑门电路 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#半加器-half-adder" class="router-link-active router-link-exact-active sidebar-item" aria-label="半加器（Half Adder）"><!--[--><!--]--> 半加器（Half Adder） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#半加器和全加器-full-adder" class="router-link-active router-link-exact-active sidebar-item" aria-label="半加器和全加器（Full Adder）"><!--[--><!--]--> 半加器和全加器（Full Adder） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#八位计算单元" class="router-link-active router-link-exact-active sidebar-item" aria-label="八位计算单元"><!--[--><!--]--> 八位计算单元 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#原码、反码、补码" class="router-link-active router-link-exact-active sidebar-item" aria-label="原码、反码、补码"><!--[--><!--]--> 原码、反码、补码 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#alu-arithmetic-logic-unit-算术逻辑单元" class="router-link-active router-link-exact-active sidebar-item" aria-label="ALU（Arithmetic Logic Unit）算术逻辑单元"><!--[--><!--]--> ALU（Arithmetic Logic Unit）算术逻辑单元 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#存储单元" class="router-link-active router-link-exact-active sidebar-item" aria-label="存储单元"><!--[--><!--]--> 存储单元 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#ram" class="router-link-active router-link-exact-active sidebar-item" aria-label="RAM"><!--[--><!--]--> RAM <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#地址选择器" class="router-link-active router-link-exact-active sidebar-item" aria-label="地址选择器"><!--[--><!--]--> 地址选择器 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#_8位计算机实现" class="router-link-active router-link-exact-active sidebar-item" aria-label="8位计算机实现"><!--[--><!--]--> 8位计算机实现 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#机器语言和汇编语言" class="router-link-active router-link-exact-active sidebar-item" aria-label="机器语言和汇编语言"><!--[--><!--]--> 机器语言和汇编语言 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#缓存" class="router-link-active router-link-exact-active sidebar-item" aria-label="缓存"><!--[--><!--]--> 缓存 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#准备工作" class="router-link-active router-link-exact-active sidebar-item" aria-label="准备工作"><!--[--><!--]--> 准备工作 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#_1、指令是如何运行的" class="router-link-active router-link-exact-active sidebar-item" aria-label="1、指令是如何运行的"><!--[--><!--]--> 1、指令是如何运行的 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#_2、计算机的基本构成" class="router-link-active router-link-exact-active sidebar-item" aria-label="2、计算机的基本构成"><!--[--><!--]--> 2、计算机的基本构成 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#_3、计算机是如何启动的" class="router-link-active router-link-exact-active sidebar-item" aria-label="3、计算机是如何启动的"><!--[--><!--]--> 3、计算机是如何启动的 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#_4、x86汇编的准备工作" class="router-link-active router-link-exact-active sidebar-item" aria-label="4、X86汇编的准备工作"><!--[--><!--]--> 4、X86汇编的准备工作 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#x86-64与amd64" class="router-link-active router-link-exact-active sidebar-item" aria-label="x86_64与amd64"><!--[--><!--]--> x86_64与amd64 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#将汇编代码编译成二进制文件" class="router-link-active router-link-exact-active sidebar-item" aria-label="将汇编代码编译成二进制文件"><!--[--><!--]--> 将汇编代码编译成二进制文件 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#模拟器运行" class="router-link-active router-link-exact-active sidebar-item" aria-label="模拟器运行"><!--[--><!--]--> 模拟器运行 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#将二进制文件写入虚拟硬盘" class="router-link-active router-link-exact-active sidebar-item" aria-label="将二进制文件写入虚拟硬盘"><!--[--><!--]--> 将二进制文件写入虚拟硬盘 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#真机运行" class="router-link-active router-link-exact-active sidebar-item" aria-label="真机运行"><!--[--><!--]--> 真机运行 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#mbr分区及硬盘原理" class="router-link-active router-link-exact-active sidebar-item" aria-label="MBR分区及硬盘原理"><!--[--><!--]--> MBR分区及硬盘原理 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#_1、盘片-platter" class="router-link-active router-link-exact-active sidebar-item" aria-label="1、盘片（platter）"><!--[--><!--]--> 1、盘片（platter） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#_2、磁头-head" class="router-link-active router-link-exact-active sidebar-item" aria-label="2、磁头（head)"><!--[--><!--]--> 2、磁头（head) <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#_3、磁道-track" class="router-link-active router-link-exact-active sidebar-item" aria-label="3、磁道（track）"><!--[--><!--]--> 3、磁道（track） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#_4、扇区-sector" class="router-link-active router-link-exact-active sidebar-item" aria-label="4、扇区（sector）"><!--[--><!--]--> 4、扇区（sector） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#_5、柱面-cylinder" class="router-link-active router-link-exact-active sidebar-item" aria-label="5、柱面（cylinder)"><!--[--><!--]--> 5、柱面（cylinder) <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#磁盘拆解图" class="router-link-active router-link-exact-active sidebar-item" aria-label="磁盘拆解图"><!--[--><!--]--> 磁盘拆解图 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#不同磁道上扇区的长度不一样-为什么容量还一样" class="router-link-active router-link-exact-active sidebar-item" aria-label="不同磁道上扇区的长度不一样，为什么容量还一样"><!--[--><!--]--> 不同磁道上扇区的长度不一样，为什么容量还一样 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#磁盘容量计算" class="router-link-active router-link-exact-active sidebar-item" aria-label="磁盘容量计算"><!--[--><!--]--> 磁盘容量计算 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#磁盘读取响应时间" class="router-link-active router-link-exact-active sidebar-item" aria-label="磁盘读取响应时间"><!--[--><!--]--> 磁盘读取响应时间 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#块-簇" class="router-link-active router-link-exact-active sidebar-item" aria-label="块/簇"><!--[--><!--]--> 块/簇 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#page-页" class="router-link-active router-link-exact-active sidebar-item" aria-label="Page（页）"><!--[--><!--]--> Page（页） <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#扇区、块-簇、page的关系" class="router-link-active router-link-exact-active sidebar-item" aria-label="扇区、块/簇、page的关系"><!--[--><!--]--> 扇区、块/簇、page的关系 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#汇编是如何跑起来的" class="router-link-active router-link-exact-active sidebar-item" aria-label="汇编是如何跑起来的"><!--[--><!--]--> 汇编是如何跑起来的 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#显示彩色文本测试" class="router-link-active router-link-exact-active sidebar-item" aria-label="显示彩色文本测试"><!--[--><!--]--> 显示彩色文本测试 <!--[--><!--]--></a><!----></li><!--]--></ul></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#认识汇编语言" class="router-link-active router-link-exact-active sidebar-item" aria-label="认识汇编语言"><!--[--><!--]--> 认识汇编语言 <!--[--><!--]--></a><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#深入mov指令及内存分段-了解汇编地址" class="router-link-active router-link-exact-active sidebar-item" aria-label="深入mov指令及内存分段，了解汇编地址"><!--[--><!--]--> 深入mov指令及内存分段，了解汇编地址 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#内存分段" class="router-link-active router-link-exact-active sidebar-item" aria-label="内存分段"><!--[--><!--]--> 内存分段 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#汇编地址" class="router-link-active router-link-exact-active sidebar-item" aria-label="汇编地址"><!--[--><!--]--> 汇编地址 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#汇编调试-bochs" class="router-link-active router-link-exact-active sidebar-item" aria-label="汇编调试 Bochs"><!--[--><!--]--> 汇编调试 Bochs <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/my-vuepress-blog/note/Operating%20System.html#bochs基本用法" class="router-link-active router-link-exact-active sidebar-item" aria-label="Bochs基本用法"><!--[--><!--]--> Bochs基本用法 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><p style="text-align:center;font-size:50px;font-weight:600;">Operating System</p><h2 id="计算机底层原理及电路实现" tabindex="-1"><a class="header-anchor" href="#计算机底层原理及电路实现" aria-hidden="true">#</a> 计算机底层原理及电路实现</h2><h3 id="进制转换" tabindex="-1"><a class="header-anchor" href="#进制转换" aria-hidden="true">#</a> 进制转换</h3><img src="/my-vuepress-blog/assets/202207271616604-e7ace9a7.png" alt="image-20220727161643870" style="zoom:50%;"><h3 id="真值表" tabindex="-1"><a class="header-anchor" href="#真值表" aria-hidden="true">#</a> 真值表</h3><img src="/my-vuepress-blog/assets/202207271617253-a5602da2.png" alt="image-20220727161721209" style="zoom:50%;"><h3 id="逻辑门电路" tabindex="-1"><a class="header-anchor" href="#逻辑门电路" aria-hidden="true">#</a> 逻辑门电路</h3><img src="/my-vuepress-blog/assets/202207271617968-deb7cace.png" alt="image-20220727161741928" style="zoom:50%;"><img src="/my-vuepress-blog/assets/202207271618006-2e78f3b5.png" alt="image-20220727161832963" style="zoom:50%;"><h3 id="半加器-half-adder" tabindex="-1"><a class="header-anchor" href="#半加器-half-adder" aria-hidden="true">#</a> 半加器（Half Adder）</h3><img src="/my-vuepress-blog/assets/202207271618026-2a12afb0.png" alt="image-20220727161846993" style="zoom:50%;"><h3 id="半加器和全加器-full-adder" tabindex="-1"><a class="header-anchor" href="#半加器和全加器-full-adder" aria-hidden="true">#</a> 半加器和全加器（Full Adder）</h3><img src="/my-vuepress-blog/assets/202207271619136-c294548b.png" alt="image-20220727161915100" style="zoom:50%;"><h3 id="八位计算单元" tabindex="-1"><a class="header-anchor" href="#八位计算单元" aria-hidden="true">#</a> 八位计算单元</h3><img src="/my-vuepress-blog/assets/202207271619750-c297bf30.png" alt="image-20220727161931709" style="zoom:50%;"><h3 id="原码、反码、补码" tabindex="-1"><a class="header-anchor" href="#原码、反码、补码" aria-hidden="true">#</a> 原码、反码、补码</h3><img src="/my-vuepress-blog/assets/202207271619845-8d5c669d.png" alt="image-20220727161939808" style="zoom:50%;"><h3 id="alu-arithmetic-logic-unit-算术逻辑单元" tabindex="-1"><a class="header-anchor" href="#alu-arithmetic-logic-unit-算术逻辑单元" aria-hidden="true">#</a> ALU（Arithmetic Logic Unit）算术逻辑单元</h3><img src="/my-vuepress-blog/assets/202207271619450-a02fbe2a.png" alt="image-20220727161959405" style="zoom:50%;"><h3 id="存储单元" tabindex="-1"><a class="header-anchor" href="#存储单元" aria-hidden="true">#</a> 存储单元</h3><img src="/my-vuepress-blog/assets/202207271620852-d1aacc46.png" alt="image-20220727162012801" style="zoom:50%;"><img src="/my-vuepress-blog/assets/202207271620218-bd25a6c6.png" alt="image-20220727162021176" style="zoom:50%;"><h4 id="ram" tabindex="-1"><a class="header-anchor" href="#ram" aria-hidden="true">#</a> RAM</h4><blockquote><p>简言之，RAM与DRAM的关系就是RAM包含DRAM，RAM分SRAM与DRAM，前者是静态RAM，不需要刷新，速度快，容量小，造价高，老式计算机使用。后者是动态RAM，要进行刷新，速度慢，容量大，造价低，现代计算机使用。DRAM这东西的作用就是临时存储数据（内存的作用）。</p></blockquote><h3 id="地址选择器" tabindex="-1"><a class="header-anchor" href="#地址选择器" aria-hidden="true">#</a> 地址选择器</h3><img src="/my-vuepress-blog/assets/202207271620690-eca1f966.png" alt="image-20220727162030650" style="zoom:50%;"><h3 id="_8位计算机实现" tabindex="-1"><a class="header-anchor" href="#_8位计算机实现" aria-hidden="true">#</a> 8位计算机实现</h3><img src="/my-vuepress-blog/assets/202207271620966-5ac97894.png" alt="image-20220727162039921" style="zoom:50%;"><h3 id="机器语言和汇编语言" tabindex="-1"><a class="header-anchor" href="#机器语言和汇编语言" aria-hidden="true">#</a> 机器语言和汇编语言</h3><img src="/my-vuepress-blog/assets/202207271621002-9e3b8347.png" alt="image-20220727162131956" style="zoom:50%;"><h3 id="缓存" tabindex="-1"><a class="header-anchor" href="#缓存" aria-hidden="true">#</a> 缓存</h3><img src="/my-vuepress-blog/assets/202207271621620-d2ac88b1.png" alt="image-20220727162147576" style="zoom:50%;"><h2 id="准备工作" tabindex="-1"><a class="header-anchor" href="#准备工作" aria-hidden="true">#</a> 准备工作</h2><img src="/my-vuepress-blog/assets/202207272257617-5e766df1.png" alt="image-20220727225746561" style="zoom:80%;"><h3 id="_1、指令是如何运行的" tabindex="-1"><a class="header-anchor" href="#_1、指令是如何运行的" aria-hidden="true">#</a> 1、指令是如何运行的</h3><p>我们前面制造了一台强大的计算机，它可以执行8位的加减乘除。拥有16个字节的内存，以及4个8位的寄存器。</p><p>计算机是一个很有节奏感的机器。</p><p>我们也给寄存器编个号，00，01，10，11</p><p>我们定义了4个简单的指令，LOAD_A、LOAD_B、ADD、STORE_A</p><p>现在我们就用这几个指令来写个小程序。</p><p>目的是为了把两个数字相加，然后再把结果存到内存中。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#程序对应的代码为这4行</span>
LOAD_A <span class="token number">7</span>			0000 0100			<span class="token comment">#机器码： 指令地址 内存地址</span>
LOAD_B <span class="token number">8</span>			0001 <span class="token number">1000</span>			
ADD A B				0100 0001
STORE_A <span class="token number">15</span>		<span class="token number">1000</span> <span class="token number">1111</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><strong>计算机执行这些指令分三个步骤</strong></p><ol><li>把指令拿过来、看看什么意思，然后送去执行</li><li>然后送去执行</li><li>执行完毕后再进行下一条，还是同样的步骤：取指、解码、执行</li></ol></blockquote><p>我们把刚才写的小程序放到计算机内存里。冯・诺伊曼架构的计算机是存储程序计算机，所以我们的指令必须先放到内存，计算机里存储数据、指令、包括内存地址都是二进制的。为了方便查看，我们把二进制指令转换为汇编指令。把二进制内存地址也转为十六进制。</p><blockquote><p><strong>我们把这个小程序拆分成具体动作</strong></p><ol><li>指令计数器在CPU初始化完成后，被置为0 。</li><li>然后控制单元到内存地址为0的位置取指令，这里存储的指令为 LOAD_A 7。</li><li>指令会进入IP，经过解码器解码后，会进入执行阶段，这是一个加载指令。</li><li>把门牌号为7的内存地址的内容，加载到寄存器A，7号地址存的是数字8，数字8就进入了寄存器A。</li><li>第一条指令执行完成，然后IC加1，到下一个位置取指令。</li><li>同样经过取指、解码、执行三个阶段。</li><li>LOAD_B 8 执行后，数字6就进入了寄存器B。</li><li>然后IC继续加1，这里的指令是ADD A B，寄存器A中的数字8和寄存器B中的数字6，被送往ALU的两个输入端，经过计算后产生结果 14 。</li><li>14会被控制单元再存回寄存器A，这时寄存器A的内容为数字14，IC再加1，得到STORE_A F</li><li>STORE_A指令会把寄存器A中的内容，存到门牌号为F的内存。</li><li>数字14进入F号内存地址，这个程序就执行完毕了。</li></ol><p><strong>这就是绝大多数的计算机执行指令的过程</strong></p></blockquote><h3 id="_2、计算机的基本构成" tabindex="-1"><a class="header-anchor" href="#_2、计算机的基本构成" aria-hidden="true">#</a> 2、计算机的基本构成</h3><blockquote><p>在CPU内部叫做指令流水线，有些CPU的流水线可能不止3级，而像我们定义的4个简单指令，能干的事情太少了，现实中的CPU可以执行非常多的指令，这些指令的集合就称为<strong>指令集 （IS , Introduction Set）</strong>。</p><p>每一条指令在CPU中都有对应的电路去执行，CPU就是一个巨大规模的集成电路，把指令集里面的所有指令都用电路实现了，我们称之为<strong>CPU的 指令集架构（ISA , Introduction Set Architecture）</strong>。</p><ul><li><p>起初指令集架构都是CPU的制造厂商制定的，其中非常经典的一个就是Intel提出的X86，Intel制定指令集，自己设计CPU电路，同时也拥有工厂可以自己制造CPU。Intel属于一个三位一体的技工贸公司（技术、工厂、贸易）。</p></li><li><p>后来英国ARM公司推出ARM指令集架构，但是ARM并不自行制造、销售 CPU，只是卖他们的设计授权，ARM会给出他们制定的指令集的具体电路实现。</p><ul><li>拿到授权的厂商可以直接使用ARM公司给出的设计-这个就是公版ARM。</li><li>有能力的厂商如 Apple、高通、三星等公司，会根据自己的需求，改进公版的设计。并集成更多模块，如5G基带、图像处理模块等等，产出如骁龙、A系列、猎户座等产品。这些集成度很高的产品称之为SOC，它们已经超出了传统CPU的定义。而台积电这种厂商专注于这些产品的代工。</li></ul></li><li><p>Intel、AMD等厂商，也在x86架构的处理器中集成GPU或者IO模块，向着SOC的方向发展，所以CPU和SOC的界限在逐渐变得模糊。</p></li><li><p>x86和ARM指令集都是要钱的，所以很多小公司掏不起这笔钱，这某种程度上阻碍了半导体行业的发展。</p></li><li><p>所以有个RISC-V的开源指令集面世，你可以使用这个指令集自行设计电路，这个是不要钱的，而如歌你使用RISC-V官方给出的电路设计，也就是公版的RISC-V，这个是要钱的。不过相比x86、ARM来说，对小公司已经比较友好了。</p></li></ul></blockquote><h3 id="_3、计算机是如何启动的" tabindex="-1"><a class="header-anchor" href="#_3、计算机是如何启动的" aria-hidden="true">#</a> 3、计算机是如何启动的</h3><p>CPU不是一个可以单独工作的部件，它的底部有很多金属触点，这就是它的供电来源，以及地址线、数据线等等。这种金属触点我们称之为引脚。</p><p>为了把CPU和内存、硬盘、屏幕还有鼠标键盘等连接在一起，人们需要一块可以连接这些所有设备的电路板，这个板子就是主板，不光电脑上，手机上也有只不过比较小，主板上有很多层电路，其实就是各种导线，可以建立各种不同部件之间的连接。</p><blockquote><ul><li><p>首先把CPU放置到主板的CPU插槽中，这样那些金属触点就连接到了主板的N多根导线上了，同时主板业提供了内存插槽，我们把内存也放上去，CPU和内存就建立了电路连接，它们可以交换数据了。也就是可以开始交换高低电压信号了， 为了显示，我们接入显卡并连接显示器。为了输入，我们接入鼠标键盘，还有存取数据的硬盘也接入进来，当然没有电计算机 肯定是不能工作的。</p></li><li><p>CPU第一个工作要求就是要有电，所以电源模块也接进来，一台像模像样的计算机就搭建起来了</p></li><li><p>计算机游走的都是各种高低电压信号，那么CPU要开始工作必须要有稳定持续的供电，所有计算机开始工作的第一个模块是电源，无论是没电池的台式机，还是有电池的笔记本或手机，在你把台式机电源线插入插座中或者把笔记本、手机的电池装上去的一刹那，电力供应就源源不断的来到了主板， 这时负责给计算机打拍子的时钟开始工作了，其他的部件并没有马上开始工作。</p></li><li><p>这个时候我们还没有按下开机键。开机键的侦测，也是有一个电路，按下开机键，开机电路就导通了表示收到信号，然后电力就来到了主板上，开始向各大部件供电，此时电源自己会检查主板上有没有短路，漏电的部分。，如果有则会切断所有电压输出，这是电源的自我保护，供电没什么问题后，约 300 - 500ms，电源会发出一个PowerGood信号，这时CPU工作的第二个要求满足了，时钟芯片的RST（RESET）端会收到这个信号，它开始向主板电路输出各种频率的信号，时钟电路开始打拍子，然后经过一系列复杂转换的RST信号也来到了CPU。</p></li><li><p>CPU开始进行复位（RESET）工作，比如初始化IC、IP 即指令计数器和指令寄存器，CPU复位完成后就可以开始工作了，但是这里有个问题，我们的计算机是冯•诺伊曼架构计算机，CPU要运行指令，必须从内存里拿，但是内存现在空空如也，那CPU应该先运行什么指令呢，所以要有一些指令预先内置在计算机中，而且这些指令就算没了电源，它们也必须存在。</p></li><li><p>上世纪70年代，人们发明了一种叫ROM的芯片，它就可以保存指令，而且断电不丢失。</p></li><li><p>那计算机是把ROM里存的指令复制到内存吗然后运行吗？No，复制也是计算机指令，这个复制指令从哪里来？</p><ul><li><p>所以人们采取的方式，是让ROM假装内存，让CPU以读取内存的方式来读取ROM里的指令。</p></li><li><p>前面提到CPU进行复位工作，会初始化IP，这时IP会被强制的指向ROM假装内存的位置。然后计算机就从这里开始执行第一条指令。</p></li><li><p>也就是说，你不装内存，按下开机键，也仍然按照上述流程走，但是计算机从ROM读取到第一条指令后，会开始一个开机自检（POST）的工作，像内存这种关键部是正常运行必须的，如果没有内存，ROM里的指令会确定这个机跑不起来，没有内存是个非常严重的问题，那么计算机也就不会再运行下去。</p></li><li><p>ROM里存储的指令有很多，是一大把指令的合集，我们称之为一个程序，ROM里的这个程序，叫做BIOS（基本输入输出系统）。后来升级了一次，搞得比较花里胡哨，叫UEFI，UEFI很复杂，但是功能都差不多，就是把计算机拉起来。</p></li><li><p>计算机启动叫boot，除了开机自检外，BIOS或者UEFI，还会提供基本的键盘鼠标输入输出和画面显示。那么这个时候计算机内存中还是没有东西，接下来该往哪执行呢？ROM里的BIOS程序并不大，它提供了一个从硬盘上寻找程序的方法，并且可以把它找到的程序送到内存中执行，这时计算机才真正进入节奏。</p></li><li><p>以上是x86体系计算机的启动过程，ARM提示其实大同小异，最开始内存中都没有东西。必须先运行一些ROM里的代码，然后再到存储设备上继续找程序，找到了就继续运行，道理是一样的道理。</p></li><li><p>BIOS或者UEFI程序通常都不大，只能提供一些计算机基本能力，所以它们会在硬盘上寻找操作系统，找到了就把它加载到内存开始运行。其实严格意义上来说，它们是在找一个叫BootLoader的程序。</p></li><li><p>BootLoader会被加载到内存一个特定的位置 0x7c00，<strong>至于为什么加载到这里，后面再解释</strong>。BootLoader就是我们写汇编程序的起点了，这也是我们编程之路离计算机底层最近的地方了 ，先找到这个程序，这个程序再把操作系统拉起来。操作系统是一个比较大的程序，它会提供更多的功能，更友好的用户界面，让用户可以不用再直面赤裸裸的硬件，只要动动鼠标、敲敲键盘就能在网络上指点江山，<strong>关于操作系统，我们后面再更加深入详细的介绍</strong>。后面的学习，我们会从x86汇编语言入手，为什么不选ARM或者RISC-V，主要是老师还没学会，等老师学会了再开课讲。</p></li></ul></li></ul></blockquote><h3 id="_4、x86汇编的准备工作" tabindex="-1"><a class="header-anchor" href="#_4、x86汇编的准备工作" aria-hidden="true">#</a> 4、X86汇编的准备工作</h3><p><strong>下面将记录从汇编程序到模拟器以及真机运行的过程以及用到的工具和过程中遇到的问题，过程中用到的工具暂时不具体研究。</strong></p><h4 id="x86-64与amd64" tabindex="-1"><a class="header-anchor" href="#x86-64与amd64" aria-hidden="true">#</a> x86_64与amd64</h4><blockquote><p><strong>x86_64与amd64</strong> 由于32位系统x86架构的种种限制，包括速度，性能等方面，Intel开始向64位架构发展，那么有2选择：</p><ul><li>向下兼容x86</li><li>完全重新设计指令集，不兼容x86</li><li>结果AMD领先，比Intel率先制造出了商用的兼容x86的CPU，AMD称之为AMD64，抢了64位PC的第一桶金，得到了用户的认同。</li><li>而Intel选择了设计一种不兼容x86的全新64为指令集，称之为IA-64，但是比amd晚了一步，而且IA-64也挺惨淡的，因为是全新设计的CPU，没有编译器，也不支持windows（微软把intel给忽悠了，承诺了会出安腾版windows server版，但是迟迟拿不出东西）。。。后来不得不在时机落后的情况下也开始支持AMD64的指令集，但是换了个名字，叫x86_64，表示是x86指令集的64扩展。</li><li>也就是说实际上，x86_64,x64,AMD64基本上是同一个东西，我们现在用的intel/amd的桌面级CPU基本上都是x86_64</li></ul><p><strong>i386</strong></p><p>首先可以简化一个概念，i386=Intel 80386。 其实i386通常被用来作为对Intel（英特尔）32位微处理器的统称。但是目前更多的时候，我们公认i386为32位系统，其实就是x86了。</p></blockquote><h4 id="将汇编代码编译成二进制文件" tabindex="-1"><a class="header-anchor" href="#将汇编代码编译成二进制文件" aria-hidden="true">#</a> 将汇编代码编译成二进制文件</h4><blockquote><p><strong>NASM</strong></p><p>Netwide Assembler （简称 <strong>NASM</strong>）是一款<strong>基于x86架构的汇编与反汇编软件</strong>。它可以用来编写16位（8086、80286等）、32位（IA-32）和64位（x86_64）的程序。 NASM被认为是Linux平台上最受欢迎的汇编工具之一。 NASM 最初是在朱利安·霍尔（Julian Hall）的协助下由西蒙·泰瑟姆（Simon Tatham）开发的 [2] 。 截至2016年，它被一个由Hans Peter Anvin领导的小团队所维护。 [1] 它是一款基于简化版BSD许可证（2-clause BSD License）的开放源代码软件。</p><p>汇编指令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>nasm <span class="token parameter variable">-f</span> bin xxx.asm <span class="token parameter variable">-o</span> xxx.bin
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></blockquote><p>​</p><h4 id="模拟器运行" tabindex="-1"><a class="header-anchor" href="#模拟器运行" aria-hidden="true">#</a> 模拟器运行</h4><blockquote><p><strong>QEMU</strong></p><p>QEMU是一套由法布里斯·贝拉(Fabrice Bellard)所编写的以GPL许可证分发源码的模拟处理器软件，在GNU/Linux平台上使用广泛。Bochs，PearPC等与其类似，但不具备其许多特性，比如高速度及跨平台的特性，通过KQEMU这个闭源的加速器，QEMU能模拟至接近真实电脑的速度。 0.9.1及之前版本的qemu可以使用kqemu加速器。在qemu1.0之后的版本，都无法使用kqemu，主要利用qemu-kvm加速模块，并且加速效果以及稳定性明显比kqemu好。</p><p>创建一个虚拟硬盘</p><blockquote><p><strong>qemu-img生成虚拟硬盘镜像格式参数</strong></p><table><thead><tr><th style="text-align:center;">虚拟硬盘格式</th><th style="text-align:center;">对应qemu-img 的参数</th></tr></thead><tbody><tr><td style="text-align:center;">QCOW2（<a href="https://so.csdn.net/so/search?q=KVM&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener noreferrer">KVM<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>、Xen）</td><td style="text-align:center;"><code>qcow2</code></td></tr><tr><td style="text-align:center;">QED (KVM)</td><td style="text-align:center;"><code>qed</code></td></tr><tr><td style="text-align:center;">raw</td><td style="text-align:center;"><code>raw</code></td></tr><tr><td style="text-align:center;">VDI (VirtualBox)</td><td style="text-align:center;"><code>vdi</code></td></tr><tr><td style="text-align:center;">VHD (Hyper-V)</td><td style="text-align:center;"><code>vpc</code></td></tr><tr><td style="text-align:center;">VMDK (VMware)</td><td style="text-align:center;"><code>vmdk</code></td></tr></tbody></table></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#创建一个16MB的VHD格式虚拟硬盘，输出一个VHD格式的虚拟硬盘文件</span>
<span class="token comment">#qemu-img默认创建的是动态的虚拟硬盘，输出的vhd文件才几kb，应该是随着文件变存进去才变大的。</span>
<span class="token comment">#支持写入动态虚拟硬盘的工具很少（我没找到），用不支持动态格式的工具会导致虚拟硬盘损坏</span>
<span class="token comment">#虚拟硬盘本质是一个文件，里面存储着一些描述这个硬盘的信息，不支持动态格式的工具会导致这些信息被覆盖。</span>
qemu-img create <span class="token parameter variable">-f</span> vpc xxx.vhd 16M  

<span class="token comment">#可以通过subformat=fixed参数时VHD也变成固定类型的虚拟硬盘，创建多大的虚拟硬盘输出的虚拟硬盘文件就占用多大的空间。</span>
<span class="token comment">#描述硬盘的信息，存储在这个虚拟硬盘的最后一个扇区。</span>
qemu-img create <span class="token parameter variable">-f</span> vpc <span class="token parameter variable">-o</span> <span class="token assign-left variable">subformat</span><span class="token operator">=</span>fixed xxx.vhd 16M

<span class="token comment">#也可以选择raw格式，默认就是固定的大小。</span>
qemu-img create <span class="token parameter variable">-f</span> raw <span class="token parameter variable">-o</span> xxx.raw 16M 

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><h4 id="将二进制文件写入虚拟硬盘" tabindex="-1"><a class="header-anchor" href="#将二进制文件写入虚拟硬盘" aria-hidden="true">#</a> 将二进制文件写入虚拟硬盘</h4><blockquote><p>Linux <strong>dd</strong> 命令用于读取、转换并输出数据。</p><p>dd 可从标准输入或文件中读取数据，根据指定的格式来转换数据，再输出到文件、设备或标准输出。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>xxx.bin <span class="token assign-left variable">of</span><span class="token operator">=</span>xxx.vhd <span class="token assign-left variable">bs</span><span class="token operator">=</span><span class="token number">512</span> <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">conv</span><span class="token operator">=</span>notrunc
<span class="token comment">#if 文件名：输入文件名，默认为标准输入。即指定源文件。</span>
<span class="token comment">#of=文件名：输出文件名，默认为标准输出。即指定目的文件。</span>

<span class="token comment">#ibs=bytes：一次读入bytes个字节，即指定一个块大小为bytes个字节。</span>
<span class="token comment">#obs=bytes：一次输出bytes个字节，即指定一个块大小为bytes个字节。</span>
<span class="token comment">#bs=bytes：同时设置读入/输出的块大小为bytes个字节。</span>
<span class="token comment">#cbs=bytes：一次转换bytes个字节，即指定转换缓冲区大小。</span>

<span class="token comment">#skip=blocks：从输入文件开头跳过blocks个块后再开始复制。</span>
<span class="token comment">#seek=blocks：从输出文件开头跳过blocks个块后再开始复制。</span>
<span class="token comment">#count=blocks：仅拷贝blocks个块，块大小等于ibs指定的字节数。</span>

<span class="token comment">#conv=&lt;关键字&gt;，关键字可以有以下11种：</span>
  <span class="token comment"># conversion：用指定的参数转换文件。</span>
  <span class="token comment"># ascii：转换ebcdic为ascii</span>
  <span class="token comment"># ebcdic：转换ascii为ebcdic</span>
  <span class="token comment"># ibm：转换ascii为alternate ebcdic</span>
  <span class="token comment"># block：把每一行转换为长度为cbs，不足部分用空格填充</span>
  <span class="token comment"># unblock：使每一行的长度都为cbs，不足部分用空格填充</span>
  <span class="token comment"># lcase：把大写字符转换为小写字符</span>
  <span class="token comment"># ucase：把小写字符转换为大写字符</span>
  <span class="token comment"># swap：交换输入的每对字节</span>
  <span class="token comment"># noerror：出错时不停止</span>
  <span class="token comment"># notrunc：不截短输出文件（不加这个参数会导致整个文件变成输入的大小，原有的多出的数据会截掉，可能会导致文件损坏。加了之后只是输入多大就覆盖多大，除非输入大小大于被输入文件大小，否则一般不会发生什么问题）</span>
  <span class="token comment"># sync：将每个输入块填充到ibs个字节，不足部分用空（NUL）字符补齐。</span>

<span class="token comment">#--help：显示帮助信息</span>
<span class="token comment">#--version：显示版本信息</span>

<span class="token comment">#读指定物理扇区：</span>
<span class="token function">dd</span>  <span class="token assign-left variable">if</span><span class="token operator">=</span><span class="token operator">&lt;</span>源设备<span class="token operator">&gt;</span>  <span class="token assign-left variable">of</span><span class="token operator">=</span><span class="token operator">&lt;</span>输出设备或文件<span class="token operator">&gt;</span>   <span class="token assign-left variable">skip</span><span class="token operator">=</span><span class="token operator">&lt;</span>指定扇区值<span class="token operator">&gt;</span>  <span class="token assign-left variable">bs</span><span class="token operator">=</span><span class="token number">512</span> <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token comment">#写指定物理扇区：</span>
<span class="token function">dd</span>   <span class="token assign-left variable">if</span><span class="token operator">=</span><span class="token operator">&lt;</span>输入设备或文件<span class="token operator">&gt;</span>   <span class="token assign-left variable">of</span><span class="token operator">=</span><span class="token operator">&lt;</span>输出设备<span class="token operator">&gt;</span>   <span class="token assign-left variable">seek</span><span class="token operator">=</span><span class="token operator">&lt;</span>指定扇区值<span class="token operator">&gt;</span>  <span class="token assign-left variable">bs</span><span class="token operator">=</span><span class="token number">512</span> <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">1</span> <span class="token assign-left variable">conv</span><span class="token operator">=</span>notrunc
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><p><strong>QEMU运行程序</strong></p><blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#不指定硬盘格式，QEMU会有警告，例如：Image format was not specified for &#39;hello.vhd&#39; and probing guessed raw...</span>
qemu-system-x86_64 xxx.vhd
<span class="token comment">#指定启动硬盘格式，如果虚拟硬盘没有问题，不会有警告</span>
qemu-system-x86_64 <span class="token parameter variable">-drive</span> <span class="token assign-left variable">file</span><span class="token operator">=</span>hello.vhd,format<span class="token operator">=</span>vpc

<span class="token comment"># 或 qemu-system-i386</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><h4 id="真机运行" tabindex="-1"><a class="header-anchor" href="#真机运行" aria-hidden="true">#</a> 真机运行</h4><blockquote><p>把x86_64程序写入到硬盘并在真机启动</p><ul><li>WIndows可以用WinHex来打开U盘，MacOS可以用 Hex Fiend，复制程序的二进制代码，写入到U盘的起始位置。重启电脑选择U盘启动。</li><li>由于没有x86设备，所以只能用qemu模拟，测试并没有问题，有机会再用真机测试。</li></ul></blockquote><h2 id="mbr分区及硬盘原理" tabindex="-1"><a class="header-anchor" href="#mbr分区及硬盘原理" aria-hidden="true">#</a> MBR分区及硬盘原理</h2><h3 id="_1、盘片-platter" tabindex="-1"><a class="header-anchor" href="#_1、盘片-platter" aria-hidden="true">#</a> 1、<strong>盘片（platter）</strong></h3><h3 id="_2、磁头-head" tabindex="-1"><a class="header-anchor" href="#_2、磁头-head" aria-hidden="true">#</a> 2、<strong>磁头（head)</strong></h3><p>硬盘中一般会有多个盘片组成，每个盘片包含两个面，每个盘面都对应地有一个磁头（读/写）。</p><p>受到硬盘整体体积和生产成本的限制，盘片数量都受到限制，一般都在5片以内。盘片的编号自下向上从0开始，如最下边的盘片有0面和1面，再上一个盘片就编号为2面和3面。</p><img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202208051551813.png" alt="2843224-46fb935cd31addbd" style="zoom:50%;"><h3 id="_3、磁道-track" tabindex="-1"><a class="header-anchor" href="#_3、磁道-track" aria-hidden="true">#</a> 3、<strong>磁道（track）</strong></h3><h3 id="_4、扇区-sector" tabindex="-1"><a class="header-anchor" href="#_4、扇区-sector" aria-hidden="true">#</a> 4、<strong>扇区（sector）</strong></h3><p>下图显示的是一个盘面，盘面中一圈圈灰色同心圆为一条条磁道，从圆心向外画直线，可以将磁道划分为若干个弧段，每个磁道上一个弧段被称之为一个扇区（图践绿色部分）。</p><p>扇区是磁盘的最小组成单元，通常是512字节。（由于不断提高磁盘的大小，部分厂商设定每个扇区的大小是4096字节）</p><img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202208051553635.png" alt="2843224-56f2056f0b36009f" style="zoom:50%;"><h3 id="_5、柱面-cylinder" tabindex="-1"><a class="header-anchor" href="#_5、柱面-cylinder" aria-hidden="true">#</a> 5、<strong>柱面（cylinder)</strong></h3><p>硬盘通常由重叠的一组盘片构成，每个盘面都被划分为数目相等的磁道，并从外缘的“0”开始编号，具有相同编号的磁道形成一个圆柱，称之为磁盘的柱面。</p><p>磁盘的柱面数与一个盘面上的磁道数是相等的。</p><p>由于每个盘面都有自己的磁头，因此，盘面数等于总的磁头数。 如下图</p><img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202208051554089.png" alt="2843224-e0854f19c817c83c" style="zoom:50%;"><h3 id="磁盘拆解图" tabindex="-1"><a class="header-anchor" href="#磁盘拆解图" aria-hidden="true">#</a> 磁盘拆解图</h3><img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202208051314930.png" alt="R-C" style="zoom:50%;"><blockquote><p>硬盘这种设备，就是依靠在圆盘上写入磁信息来存储数据的，有磁或没磁可以代表1或者0。</p><ul><li><p>圆盘被一个叫磁臂的结构夹住，上下两面（正面和背面）都有，磁臂最末端有磁头，每个圆盘都有两面（正面和背面），每一个面都有一个磁头。</p></li><li><p>磁头就是用来读取圆盘上的信息的。</p></li><li><p>通常我们会用磁头来代表盘面，第一个盘面上的磁头编号为0，我们就称为0面，下面磁头编号为1，称为1面。</p></li><li><p>如果有更多的盘片，那么编号依次增加。</p></li></ul><img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202208051320138.png" alt="image-20220805132053091" style="zoom:50%;"></blockquote><p>硬盘数据的读取，是依赖于两部分机械运动。</p><ul><li><p>磁盘常见的转速有5400和7200转。</p></li><li><p>一个是圆盘的转动，盘片中央有个高速运动，带动盘片转动。</p></li><li><p>如果磁头不动，磁盘转一圈，那么就会形成一个圆环，这个环就叫做一个磁道。</p></li><li><p>而一个盘片有两个磁头，转动起来上下两面（正面和背面）都会形成圆环。</p></li><li><p>如果有更多的盘片，会形成更多的圆环，这些圆环是一样大的，而且是同心的，就组成了一个柱面。</p><ul><li><img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202208051410984.png" alt="image-20220805141029951" style="zoom:50%;"></li></ul></li><li><p>磁道或者柱面也是有编号的，从最边缘的编号为0开始递增 依次到圆心。</p></li></ul><p>另一个是磁臂的摆动带动磁头来回运行，磁臂带动磁头可以从最内圈转到最外圈，这样就保证磁盘上的每一个字节的数据都可以被访问到。</p><ul><li><p>磁道并不是最小的单位，一个磁道可以写入不少比特位。</p></li><li><p>磁道还可以分割，切开后的每个单位就是磁盘的最小单位，叫做扇区，每个扇区512个字节。</p></li><li><p>通常来说，一个磁道划分为63个扇区，编号从1开始。</p></li></ul><img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202208051416987.png" alt="image-20220805141626939" style="zoom:33%;"><ul><li>磁臂的移动是个机械运动，并且所有磁头都是一起移动的。 <ul><li><img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202208051459704.png" alt="image-20220805145914659" style="zoom:33%;"></li><li><img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202208051459296.png" alt="image-20220805145935249" style="zoom:33%;"></li></ul></li><li>看起来很快，但是对于CPU来说，它寻找并读取写入的速度太慢了，为了加快读取速度。 <ul><li>数据写入盘片并不是先写满0面，再写1面，而是先保持磁头不动 ，把磁头所在的柱面写满，然后再移动磁头写下一个柱面。</li><li>硬盘柱面来组织数据的。</li></ul></li></ul><p>MBR分区就存储在第0面（盘面），第0道（磁道），1扇区，只占一个扇区，所以只占512个字节。</p><img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202208051510952.png" alt="image-20220805151030911" style="zoom:33%;"><p>每台计算机都会有一个MBR分区，它会从硬盘的0道、0面、1扇区来寻找MBR。</p><img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202208051511142.png" alt="image-20220805151107104" style="zoom:33%;"><blockquote><p>MBR全称叫做主引导记录，是严格的标准结构。</p><ul><li>操作系统就是被440个字节代码区里的程序给拉起来的。</li><li>接下来4个字节是选用磁盘标志（应该是用来识别分区类型的）。</li><li>紧接着是2个字节的空值（结束标志）。</li><li>标准MBR分区表规划十分重要（记录着磁盘的信息，破坏之后会导致硬盘无法识别）。</li><li>最后两个字节是标志位，至于为什么是55AA，这时IBM工程师规定的。</li><li><img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202208051518420.jpg" alt="QQ20220805-151749@2x" style="zoom:33%;"> - Sector（扇区）第一个扇区，编号为0 </li></ul></blockquote><h3 id="不同磁道上扇区的长度不一样-为什么容量还一样" tabindex="-1"><a class="header-anchor" href="#不同磁道上扇区的长度不一样-为什么容量还一样" aria-hidden="true">#</a> 不同磁道上扇区的长度不一样，为什么容量还一样</h3><blockquote><p><strong>老硬盘</strong></p><ul><li><p><strong>老硬盘内外圈的磁道长度不一样</strong>，但是所有磁道转动的角速度是一样的，单位时间转过的长度格式化成一个扇区也是合情合理的；</p></li><li><p>由于内外磁道的扇区长度不一样，所以其实<strong>内外磁道的盘面密度应该是不一样的</strong>。</p></li></ul><p>如下说明了<strong>线性寻址硬盘的区别</strong>，所以，使用了线性寻址之后外部磁道上的扇区数目应该会更多。</p><ul><li><strong>早期的磁盘每个磁道上的扇区数目是一样，限制了磁盘的容量</strong>；</li><li><strong>后来为了增大磁盘容量采用了新技术，也就是说越往外每磁道扇区数目越多</strong>；</li><li><strong>早期的硬盘是每个磁道有相同的扇区，但是现在的硬盘采用线性寻址，所以每个磁道上扇区数不一样，外面的多，里面的少；光盘跟硬盘差不多，但是用螺线的，不像硬盘采用同心圆。</strong></li><li>不过，还是可以用CHS（柱面，磁道，扇区）的方式来定位， 因为IDE磁盘做了内部转换，让你看起来好像每条磁道上面的簇数量都是一样的</li></ul><p><strong>0磁道在磁盘的外圈，因为磁密度越低，数据越安全</strong>，而0磁道中的0扇区中存放了MBR，所以这么重要的内容自然要放到外面了。</p><p><strong>0磁道是在磁盘的外圈还是内圈</strong></p><ul><li>由于历史原因 ， 磁盘的0磁道在最外圈（过去的老式硬盘，每条磁道上的簇的数量都是一样多的。也就是说最里面和最外面的磁道的簇的数目是一样的。显然，磁密度越低，数据的安全越有保障。而MBR放在0柱面的，第0个磁道的，第1个簇上面，为了这个关键数据的安全，所以磁道要从最外开始安排。）</li><li>但是 光盘 的0磁道和 磁盘、软盘 刚好相反，光盘的0磁道是在最内圈的</li></ul></blockquote><h3 id="磁盘容量计算" tabindex="-1"><a class="header-anchor" href="#磁盘容量计算" aria-hidden="true">#</a> 磁盘容量计算</h3><blockquote><p>存储容量 ＝ 磁头数 × 柱面数 × 每道扇区数 × 每扇区字节数</p><p>例如：磁盘是一个 3个圆盘6个磁头，7个柱面（每个盘片7个磁道） 的磁盘，图3中每条磁道有12个扇区，所以此磁盘的容量为：6 * 7 * 12 * 512 = 258048</p><blockquote><p><strong>每个磁道的扇区数一样是说的老的硬盘，外圈的密度小，内圈的密度大，每圈可存储的数据量是一样的。新的硬盘数据的密度都一致，这样磁道的周长越长，扇区就越多，存储的数据量就越大。</strong></p></blockquote></blockquote><h3 id="磁盘读取响应时间" tabindex="-1"><a class="header-anchor" href="#磁盘读取响应时间" aria-hidden="true">#</a> 磁盘读取响应时间</h3><blockquote><ul><li><p><strong>寻道时间</strong>：磁头从开始移动到数据所在磁道所需要的时间，寻道时间越短，I/O操作越快，目前磁盘的平均寻道时间一般在3－15ms，一般都在10ms左右。</p></li><li><p><strong>旋转延迟</strong>：盘片旋转将请求数据所在扇区移至读写磁头下方所需要的时间，旋转延迟取决于磁盘转速。普通硬盘一般都是7200rpm，慢的5400rpm。</p></li><li><p><strong>数据传输时间</strong>：完成传输所请求的数据所需要的时间。 小结一下：从上面的指标来看、其实最重要的、或者说、我们最关心的应该只有两个：寻道时间；旋转延迟。</p></li></ul><blockquote><p><strong>读写一次磁盘信息所需的时间可分解为：寻道时间、延迟时间、传输时间。为提高磁盘传输效率，软件应着重考虑减少寻道时间和延迟时间。</strong></p></blockquote></blockquote><h3 id="块-簇" tabindex="-1"><a class="header-anchor" href="#块-簇" aria-hidden="true">#</a> 块/簇</h3><blockquote><p><strong>磁盘块/簇（虚拟出来的）</strong>。 块是操作系统中最小的逻辑存储单位。操作系统与磁盘打交道的最小单位是磁盘块。</p><ul><li><p>通俗的来讲，在Windows下如NTFS等文件系统中叫做簇；</p></li><li><p>在Linux下如Ext4等文件系统中叫做块（block）。</p></li><li><p>每个簇或者块可以包括2、4、8、16、32、64，...个扇区（也就是2的n次方个扇区）。</p></li></ul><p><strong>为什么存在磁盘块？</strong></p><ul><li><p><strong>读取方便：由于扇区的容量比较小，数目众多在寻址时比较困难，所以操作系统就将相邻的扇区组合在一起，形成一个块，再对块进行整体的操作。</strong></p></li><li><p><strong>分离对底层的依赖：操作系统忽略对底层物理存储结构的设计。通过虚拟出来磁盘块的概念，在系统中认为块是最小的单位。</strong></p></li></ul></blockquote><h3 id="page-页" tabindex="-1"><a class="header-anchor" href="#page-页" aria-hidden="true">#</a> Page（页）</h3><blockquote><p>操作系统经常与内存和硬盘这两种存储设备进行通信，类似于“块”的概念，内存和硬盘都需要一种虚拟的基本单位。</p><ul><li><p><strong>与内存操作，是虚拟一个页的概念来作为最小单位</strong>。</p></li><li><p><strong>与硬盘打交道，就是以块为最小单位</strong>。</p></li></ul></blockquote><h3 id="扇区、块-簇、page的关系" tabindex="-1"><a class="header-anchor" href="#扇区、块-簇、page的关系" aria-hidden="true">#</a> 扇区、块/簇、page的关系</h3><blockquote><ul><li><p><strong>扇区： 硬盘的最小读写单元。</strong></p></li><li><p><strong>块/簇： 是操作系统针对硬盘读写的最小单元。</strong></p></li><li><p><strong>page： 是内存与操作系统之间操作的最小单元。</strong></p></li><li><p>扇区 &lt;= 块/簇 &lt;= page</p></li></ul></blockquote><h2 id="汇编是如何跑起来的" tabindex="-1"><a class="header-anchor" href="#汇编是如何跑起来的" aria-hidden="true">#</a> 汇编是如何跑起来的</h2><blockquote><img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202208051636602.jpg" alt="QQ20220805-163530@2x" style="zoom:33%;"><ul><li><p>计算机是个严谨的机器，CPU是计算机的核心。</p></li><li><p>所有部件紧紧团结在中央处理器周围。</p></li><li><p>计算机是用来做计算的，数据从外部存储设备比如硬盘、U盘、光盘或者键盘输入等。</p></li><li><p>进入计算机的内存，内存的数据再进入寄存器。</p></li><li><p>现代CPU在内存和寄存器之间还有高速缓存（暂时不在我们的研究范围）。</p></li><li><p>寄存器就是距离计算核心最近的存储设备了。</p></li></ul></blockquote><blockquote><p>​ <img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202208061213911.png" alt="image-20220806121313835" style="zoom:33%;"></p><ul><li><p>所以我们研究汇编语言，要从寄存器往外拓展。</p></li><li><p>x86的开山鼻祖是Intel的8086处理器，这就是我们学习x86汇编的起点。</p></li><li><p>8086是一个16位的处理器，寄存器、内部以及外部数据总线。</p></li><li><p>都是16位宽的，所以是一个完全体的16位处理器。</p></li><li><p>它有8个16位的通用寄存器，每个寄存器都有自己的名字。</p></li><li><p>而计算机经常处理单字节的数据，一个字节是8位。</p></li><li><p>如果每次都用一个16位的寄存器来存储有些浪费。</p></li><li><p>所以AX、BX、CX、DX 这4个寄存器可以分别拆成2个8位寄存器来用。</p><ul><li><strong>AX、BX</strong>：通用寄存器</li><li><strong>CX、DX</strong>：段寄存器</li></ul></li><li><p>比如AX拆开后高8位叫做AH，低8位叫做AL，BX、CX、DX同理。</p></li><li><p>单独使用的时候 AH和AL互不干扰。</p></li></ul></blockquote><blockquote><img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202208061218709.jpg" alt="QQ20220806-121726@2x" style="zoom:33%;"><ul><li><p>8086一共有20根地址线，所以寻找空间是2^20=1048576/1024=1024KB=0xFFFFF。</p></li><li><p>也就是1MB，这区区1MB空间，弥足珍贵。</p></li><li><p><strong>8086可以找到从0x00000～0xFFFFF之间的所有地址</strong>。</p></li><li><p>那么这些地址是怎么分配的呢？都给内存吗？</p></li><li><p>并不是，<strong>从0x00000～0x9FFFF的部分分配给内存</strong>。一共640KB（比尔盖茨说：“人们不需要超过640KB的内存”，现在看属于扯淡，在服务器上640GB也不算太多。）</p></li><li><p><strong>0xA0000～0xBFFFF 之间的128KB分配给了显卡</strong>包括文字模式、图像模式在内的显示模式。</p></li><li><p>还有一部分<strong>0xC0000～0xFFFFF，分配给了之前提到的假装内存的BIOS部分</strong>。</p><ul><li><p>这里不光有系统ROM的芯片里面的 BIOS，还有如显卡、硬盘等BIOS信息。</p></li><li><p>0xD0000到EFFF 128KB，用于ROM存储区域。</p></li><li><p>0xF0000到FFFF 64KB，永久性的ROM区域BIOS、诊断信息等。</p></li></ul></li><li><p>老师之前看书一直有个疑问，说显卡、BIOS都映射到内存空间，现在看来这种说法并不准确，误导了老师很多年。</p></li><li><p>更准确的说法是CPU寻址范围内的部分地址分配给了其他设备。</p></li><li><p>以前老师认为，计算机装上1MB内存，显卡或者BIOS就占用了一部分，计算机就占用不了这部分内存，不是很浪费吗？</p></li><li><p>现在来时才明白，所谓映射到内存地址空间，就是映射CPU总的寻址空间。</p></li><li><p>映射部分并没有内存存在，插在主板上的内存拢共就640KB，1MB其他的部分都是假装的，并没有物理内存在那（只能寻找640KB内存）。</p></li></ul></blockquote><blockquote><img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202208061312853.png" alt="image-20220806131206793" style="zoom:33%;"><p>前面我们提到了一个特殊的内存地址，0x7c00，它刚好等于32KB-1024B，为什么呢？</p><ul><li><p>之前我们就讲过，计算机BIOS执行完POST后，会到硬盘等设备的MBR分区上找BootLoader，找到就加载到0x7c00的位置。</p></li><li><p>为什么是这个位置呢？它为什么不是0x7000这种看起来比较整齐的数字呢？</p></li><li><p>其实是IBM的锅，根CPU并没有多大关系。</p></li><li><p>0x7c00这个数字最早出现在IBM PC Model5150上，这个数字存储在它的BIOS里，所以说根CPU没关系。</p></li><li><p>这里首先要说明一下计算机启动过程中的顺序问题，从BIOS开始，只讲BIOS有关的部分。</p><ul><li>IBM PC 5150支持最大内存是32KB，也就是0x0000～0x7FFF。</li><li>第一步：当CPU收到RST信号，指令寄存器IP就被强制定位到ROM，然后从ROM里读取指令开始执行。</li><li>第二步：BIOS程序执行过程中，会产生一个叫中断向量表的东西。（这里先不解释）</li><li>同时<strong>BIOS也会用到一些内存来存储BIOS的数据，内存最开头的部分就是BIOS产生的中断向量表以及BIOS的数据</strong>。这样DRAM（动态随机访问内存）被消耗掉了一部分。</li><li>第三步：BIOS执行完POST（自检）后，没问题就开始在外部存储设备比如硬盘、CD或者U盘上的MBR分区寻找BootLoader，找到之后要运行 得加载到内存里，总得有个位置吧，是接着BIOS数据继续往后吗？并不是， <ul><li>因为BootLoader运行完后，会把操作系统拉起来，然后它就完成使命了，而它占用的内存空间也就将释放后重新利用，所以最好把它放在内存最末端，用完后释放。可以跟 <strong>除去</strong>BIOS占用的部分 ，中间的一整块内存连在一起。</li><li>那么BootLoader要占用多少空间呢？ <ul><li>Boot扇区（MBR扇区）要占用512字节，栈/数据要占512字节一共1024字节，放到32KB最后的1024个字节</li><li>BootLoader的起始位置就是 0x7FFF（32个字节） （减）0x0400（1024的十六进制）加1 得到0x7c00，（是因为不加1 得到的是 0x7BFF，这是倒数第二个1024字节的最后一个字节，所以需要加1，才是最后一个1024个字节的起始位置）</li><li>后来内存拓展到了1MB，到现在数GB，这个位置一直也没变</li></ul></li></ul></li></ul></li></ul><img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202208061320212.jpg" alt="QQ20220806-131623@2x" style="zoom:33%;"></blockquote><p>前面提到的0xAFFFF～0xBFFFF这128KB的地址空间，是分配给了图形显示，这里还需要做一个细分</p><ul><li>显卡是支持文字模式和图形模式的，其中文字模式还支持黑白和彩色文字2种</li><li>图形模式包括我们熟知的VGA等，占用0xA0000～0xAFFFF之间的64KB地址空间。</li><li>黑白文字占用0xB0000～0xB7FFF之间的32KB空间。</li><li>彩色文本占用0xB8000～0xBFFFF之间的32KB空间。</li></ul><p>这些地址空间实际上是映射到显卡的显存，当你把数据写入这些地址空间，实际上是写入到了显卡的显存里。</p><p>然后显示器会不断的从显存里的这些数据取走，然后显示在屏幕上，显卡有点类似于内存，只不过它专门用于存储显卡所需的数据。</p><p>而当下最新的显卡有十几GB，可能比内存还大，但是系统只给它分配了几百MB的地址空间，那么好像不够用怎么办？</p><img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202208061332403.png" alt="image-20220806133245333" style="zoom:50%;"><p>那就切换映射地址空间到相应的显存，比如显卡实际上有4GB显存，映射的地址空间可能只有256MB，那么首先把4GB显存开始的256MB映射到CPU寻址空间。</p><ul><li>如果不够用那就切换下一个256MB，来回切换总能把4GB映射完。</li><li>显卡也是有自己的汇编指令的，这些指令就可以完成 比如切换映射到地址空间的显存等等...</li><li>那么我们想输出黑白文字或者彩色文字，甚至图像的时候，就可以往这些地址空间写入，屏幕就会显示我们写入的内容。</li><li>显卡在初始化后，会默认进入彩色文字模式，这也是我们即将使用的模式。</li><li>黑白文字模式基本不会有人用了，图形模式等，我们后面用到再说。</li></ul><p>先聊聊彩色文字模式，顾名思义彩色就是字符可以有多种颜色</p><ul><li><p>文字模式会把显示器的整个区域分割为25行每行80个字符，也就是整个屏幕可以显示20x80=2000个字符。</p></li><li><p>为什么设计文字模式？</p><ul><li><p>工程师为了显示字符，每次都操作像素太痛苦了， 于是他们就把每个可以显示的字符的像素定义好。然后发送给显卡一个字符代号，显卡就知道该怎么显示了。</p></li><li><p>这个字符代号与字符对应关系，就是ASCII码表。比如我们想显示字符‘A’，它的编码为0x41。</p></li><li><p>不能只是单纯的把0x41发给显卡，还需要制定一个属性字节，这个字节必须紧跟在字符&#39;A&#39;后面发送。</p></li><li><p>它的含义如下， K代表是否闪烁，接着3位代表背景的RGB、I代表是否高亮，接着3位代表前景色的RGB。</p><ul><li><img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202208061348410.jpg" alt="QQ20220806-134725@2x" style="zoom:33%;"></li><li>比如：我们想显示一个黑底白字的字符 &#39;A&#39; ，就要发送0x4107到显存去，而计算机默认就是现实黑底白字，所以我们可以只发送0x41，但是必须把属性字节空出来。</li><li><img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202208061350730.png" alt="QQ20220806-135025@2x" style="zoom:33%;"></li></ul></li></ul></li></ul><img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202208061352464.png" alt="QQ20220806-135146@2x" style="zoom:33%;"><p>mov是一个传送指令，而这个byte是指定传送的数据大小，这里表示传送一个字节，也就是8位，那么0x00就代表内存地址</p><ul><li><p>[0x00]就代表内存地址，你可能会奇怪，这内存不是BIOS占用的地址吗？</p></li><li><p>我们这里就要了解一下地址分段和以及内存偏移了。</p><ul><li><p>当你打开电脑或者手机后，会打开一系列的程序，打开这些程序的顺序并不是固定的，所以它们会被随机加载到内存，即使你顺序固定，操作系统以及其他自启动的软件占用的内存大小及内存位置也是不固定的。</p></li><li><p>所以如果在编程中的时候使用绝对的物理地址，那么很可能会出现地址冲突。你想用的内存可能已经被别的程序占用了。所以我们最好使用一个相对的逻辑地址。</p></li><li><p>所以我们写程序的时候会先给定一个起始地址。</p></li><li><p>然后其他指令的地址就以起始地址为基准，开始向后（高位）递增（偏移）（目前还不知道往高位还是低位，我觉得是高位？还不确定，因为老师的图是这样的 ）</p><ul><li><img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202208061406304.png" alt="QQ20220806-140611@2x" style="zoom:33%;"></li></ul></li><li><p>而CPU执行指令就是单纯的顺序执行，所以程序的指令都是放在一起的，占用一段连续的物理地址，我们称为代码段，而数据也是一样的道理，称为数据段。</p><ul><li><p>代码段和数据和数据段就相当于两辆车</p><ul><li>代码段的驾驶座就是CS（Code Segment）寄存器。</li><li>数据段的的驾驶座就是DS（Data Segment）寄存器</li></ul></li><li><p>我们之前还讲过一个指令寄存器IP，它里面存储的并不是绝对物理地址， 而是相对于CS的偏移，也就是说，CPU访问指令 是通过段地址：偏移地址的模式来进行的。</p><ul><li><strong>CS指定代码段的基准地址</strong>，IP指定代码段的偏移地址<img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202208061416385.jpg" alt="QQ20220806-141424@2x" style="zoom:33%;"></li><li><strong>DS指定数据段基准地址</strong>，再增加相应的偏移地址来访问数据。</li></ul></li></ul></li></ul></li></ul><p>8086处理器有些特殊，它是16位处理器，但是有20根地址线，原因是16根地址线最大寻址空间只有64KB，即使在那个年代也是low。所以Intel就拓展了4根，20根线寻址空间就有1MB了，那么这就回导致一个问题，段寄存器和IP寄存器都是16位的，那么两个16位的数字相加还是16位，20根线怎么搞呢？</p><ul><li>8086是这样解决的，在把逻辑地址转成物理地址前，先把段寄存器左移4位，这就有20位了，再加上16位偏移地址，就可以访问全部地址空间了。 1. <img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202208061503784.png" alt="image-20220806150332688" style="zoom:33%;"> <img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202208061504532.png" alt="image-20220806150409479" style="zoom:33%;"></li></ul><p>这时候我们就可以解释start.asm的第二行代码了，mov ds ax 这个意思就是指定数据段的基准地址。</p><img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202208061507495.png" alt="image-20220806150703414" style="zoom:33%;"><p>​ 后面的[0x02]一直到[0x26]都是同理，而&#39;A&#39;是nasm可以接受的3种数据格式之一</p><img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202208061509619.jpg" alt="QQ20220806-150819@2x" style="zoom:33%;"><img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202208061511643.png" alt="image-20220806151124566" style="zoom:33%;"><ul><li>jmp是一个跳转指令，我们之前说IP是指令寄存器，CPU规定了，我们不能直接修改它，但是我们程序里的指令并不一定是完全顺序执行的，也会有判断逻辑，走向不同的处理流程，或者要循环执行，同一些指令要重复执行多次，那么就可以通过jmp指令来间接的修改IP。 <ul><li><strong>jmp $就是跳转到jmp所在的位置</strong>，主要是为了提供一个标志。</li><li>而最后db 0x55,0xaa，就是MBR分区最后的标志位。</li><li>同时我们知道MBR是512个字节，所以从jmp $ 到0x55之间的位置，我们通过times 510-($-$$) db0这行代码补满0。</li><li>$$代表起始位置，$代表jmp所在的位置</li><li>那么$$-$就是从开头到jmp的位置一共有多少个字节。</li><li>然后512-2个字节的标志位55，aa得到510，510再减($-$$)得到了应该填充的0个数)</li></ul></li></ul><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>mov ax,0b800h #显存地址放入ax寄存器
mov ds,ax #把ax的数据传送到ds设置数据段的基准地址

mov byte[0x00],&#39;H&#39; #0xxx是像相对于ds基准地址的偏移
mov byte[0x02],&#39;e&#39;
mov byte[0x04],&#39;l&#39;
mov byte[0x06],&#39;l&#39;
mov byte[0x08],&#39;o&#39;
mov byte[0x0a],&#39;,&#39;
mov byte[0x0c],&#39;N&#39;
mov byte[0x0e],&#39;i&#39;
mov byte[0x10],&#39;H&#39;
mov byte[0x12],&#39;a&#39;
mov byte[0x14],&#39;o&#39;
mov byte[0x16],&#39;\n&#39;

jmp $  #这个在执行期间会进入循环 不然程序执行完之后就停止了，类似单片机的 while(1)作用；在编译期间可以作为一个标志
#以下这些代码应该是在编译时期执行的，上面的则应该是在编译成机器代码后运行时执行的
times 510 - ($ - $$) db 0 #510减去结束标志 - jmp位置 - 开始位置 得到从 jmp $后面开始 一直到 510 这个位置 全部填充0
db 0x55,0xaa  #在第511和512字节的位置填充结束标志
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><ul><li><p><strong>mov</strong>：它是move的缩写，是x86的一条汇编指令，主要功能就是传送数据。mov后面会有两个操作对象。</p><ul><li><p>dest 目标（目的地）：</p></li><li><p>src 源（发车地）：</p></li><li><p>即：mov &lt;dest&gt; &lt;src&gt;</p></li><li><p>上面代码意思：</p><ul><li>ax：是CPU里的一个通用寄存器</li><li>0b800h：这是一个十六进制的显存地址，也可以写作 0x0b800</li><li>这行代码执行完后，ax里的内容会变成0b800h</li></ul></li></ul></li></ul></blockquote><h3 id="显示彩色文本测试" tabindex="-1"><a class="header-anchor" href="#显示彩色文本测试" aria-hidden="true">#</a> 显示彩色文本测试</h3><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>mov ax,0b800h
mov ds,ax

mov byte[0x00],&#39;L&#39;
mov byte[0x01],0x8c
mov byte[0x02],&#39;i&#39;
mov byte[0x03],0x8c
mov byte[0x04],&#39;u&#39;
mov byte[0x05],0x8c
mov byte[0x06],&#39; &#39;
mov byte[0x08],&#39;y&#39;
mov byte[0x09],0x8a
mov byte[0x0a],&#39;u&#39;
mov byte[0x0b],0x8a
mov byte[0x0c],&#39; &#39;
mov byte[0x0e],&#39;P&#39;
mov byte[0x0f],0x89
mov byte[0x10],&#39;e&#39;
mov byte[0x11],0x89
mov byte[0x12],&#39;i&#39;
mov byte[0x13],0x89
mov byte[0x14],&#39; &#39;

jmp $

times 510-($-$$) db 0
db 0x55,0xaa
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202208061610167.png" alt="image-20220806161015065" style="zoom:33%;"><h2 id="认识汇编语言" tabindex="-1"><a class="header-anchor" href="#认识汇编语言" aria-hidden="true">#</a> 认识汇编语言</h2><p>现在我们要了解5W1H，就是 what why who when where how</p><p>要解释汇编语言是什么，得往底层走，计算机在硬件层面，是里面的高低电压在策马扬鞭。</p><p>当然电压你是无法直接看见或者听见的，控制方法很简单粗暴。</p><p>早起的计算机，是通过拨动开关或者拔擦电线，来控制计算机的，当年计算机很庞大，而且元件、电线都是裸露的，比较容易坏。</p><p>比如编程语言之母格雷斯模式在为 Mark || 型计算机写程序的时候，查找一个问题，最后发现计算机里有个虫子，弄坏了一个元件，导致计算出错。虫子的应为就是 Bug ，从此 Bug 就成为了计算机软硬件缺陷的代名词。</p><p>然而通过开关或者插拔电线的方式，实在是繁琐且容易出错，所以人们用 0 和 1 代表低电压和高电压，当然这并不代表人们就使用二进制键盘编程， 只是一种人类更加容易理解的信息，这些 0 和 1 的序列，就可以控制计算机 CPU进行各种动作。</p><p>一组一组的0、1序列就是一个一个指令，这些指令就形成了一种语言，称之为机器语言。</p><ul><li>具体这些机器语言是怎么输入的呢？首先你用 0 和 1 在纸上写好了程序，然后再把这个程序的01序列打到纸带上，纸带上分割成等长的块，每一块上有孔代表1，没孔代表0，计算机读入程序就是用一个探针去戳，戳到孔就是1没有就是0。</li><li><img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202208061638236.png" alt="image-20220806163806146" style="zoom:33%;"></li></ul><p>机器语言还是太繁琐了，也很容易出错，比如少打了个孔 或者 多打了，这不太容易找出来，找到后改程序的方式也是简单粗暴，如果少打了就戳上孔，如果多打了，就拿胶带补上。这就叫做一个Patch，也就是补丁，我们常听说的补丁就是这么来的。</p><p>聪明或者说懒惰的人类，再次发动了脑筋，0和1的序列不好记，那我们就给它们起个代号。我们之前也简单定义过几个指令用Load_A来代替0000，用LOAD_B 来代替0001，...</p><img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202208061642383.png" alt="image-20220806164207283" style="zoom:33%;"><p>这样对人类来说，会更加易读，变成国层会更加友好，那么这就是汇编语言。</p><p>汇编语言是非常接近计算机底层的 ，所以它才会让你更加深入的了解计算机，你了解的越深入，编程其实对你来说就更容易。</p><p>然而汇编语言仍然相对来说比较繁琐，实现一点点功能都要写很多行代码。 所以人们又产生了新的想法，我们能不能把这些汇编语言打个包呢？让我写一行代码就能写10行汇编，于是高级语言就顺理成章的出来了。</p><p>高级语言比如：C、C++、Java、Python的呢固定呢个，编程效率的确比汇编语言高多了。</p><p>但是并不能代表它们比汇编高贵，任何语言能做的事，汇编都能做，毕竟高级语言就是打包了汇编语言指令，主要是考虑编程时间和效率的问题。所以汇编语言是介于机器语言和高级语言之间的一种计算机指令代号。</p><p>​ 它是一门很接近计算机底层，连接高级语言跟计算机硬件的编程语言。</p><p>为什么学习汇编，想称为一个大师，学习编程的路线有两种 。</p><ul><li>第一种：是从计算机底层开始学习，这个路线很高，而难度一路下降。</li><li>第二种：是从高级语言开始学起，紧接着学习各种库和框架，难度则一路上升。</li><li>也许你可以直到退休也用不到汇编，但我的观点也是：学习汇编语言，可以为学习任何编程语言打下坚实的基础，加深你对计算机系统的理解。</li><li>如果你真想成为一个编程大师，那么底层原理还有汇编语言就是必由之路。</li><li>我们花时间去做一件事，要从两个角度看收益。 <ul><li>一：是能否可以直接应用于工作中，产生经济效益，升职加薪。</li><li>二：是能否对后续的学习提升有用，也许功在当代，利在千秋。</li></ul></li></ul><p>认识第一个汇编指令</p><p>在计算机运行过程中，基本就是数据的输入、输出、处理。</p><p>我们首要解决的问题，就是搞清楚在计算机各个部件之间，数据是通过何种方式传递的，mov指令应用在哪一部分。</p><blockquote><p><strong>mov 的基本格式</strong></p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>mov  &lt;目的&gt;,&lt;源&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>目的操作数必须是一个容器，而源可以不是，mov指定的操作对象有4种</p><ul><li>通用寄存器</li><li>段寄存器</li><li>内存单元</li><li>立即数（常数）</li></ul></blockquote><blockquote><p><strong>立即数作为源操作数</strong></p><ul><li>可以传送给内存单元</li><li>可以传送给通用寄存器</li></ul><p>不能传送给立即数</p><p>不能传送给段寄存器</p></blockquote><blockquote><p><strong>内存单元作为源操作数</strong></p><ul><li>可以传送给通用寄存器</li><li>可以传送给段寄存器</li></ul><p>不能在内存单元之间传递</p><p>不能传送给立即数</p></blockquote><blockquote><p><strong>通用寄存器作为源操作数</strong></p><ul><li>可以在通用寄存器间传送</li><li>可以传送给内存单元</li><li>可以传送给段寄存器</li></ul><p>不能传送给立即数</p></blockquote><blockquote><p><strong>段寄存器作为源操作数</strong></p><ul><li>可以传送给通用寄存器</li><li>可以传送给内存单元</li></ul><p>不能在段寄存器之间传递</p><p>不能传送给立即数</p></blockquote><img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202208061714233.jpg" alt="QQ20220806-171412@2x" style="zoom:33%;"></blockquote><h3 id="深入mov指令及内存分段-了解汇编地址" tabindex="-1"><a class="header-anchor" href="#深入mov指令及内存分段-了解汇编地址" aria-hidden="true">#</a> 深入mov指令及内存分段，了解汇编地址</h3><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>mov &lt;位宽&gt; &lt;目的操作数&gt; &lt;源操作数&gt;
		byte		8							8				#1个字节			占1个字节的数据			占1个字节的数据
		word		16						16			#2个字节			占1个字节的数据			占1个字节的数据
		dword		32						32			#4个字节			占1个字节的数据			占1个字节的数据
		qword 	64						64			#8个字节			占1个字节的数据			占1个字节的数据
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>mov指令9种情况分析</p><blockquote><p>立即数传送到内存，必须用位宽修饰符，而且位宽修饰符最好与立即数的宽度一致，否则会有warning</p></blockquote><blockquote><p>立即数传送到通用寄存器，我们Start.asm 的第一行mov ax,0b800h</p></blockquote><blockquote><p>内存单元到通用寄存器或者段寄存器之间互传，是不需要加修饰符的，因为寄存器的宽度是固定的，8086是16位。</p></blockquote><blockquote><p>一个内存单元是1字节，而像ax是16位就是2字节。不加修饰符时，CPU会根据寄存器宽度来调整传送的数据，比如 mov ah,[0x01]，就是把0x01内存单元的数据传送给ah，因为ah是8位寄存器，也就是1字节。</p></blockquote><blockquote><p>再比如mov ax,[0x02]，就是把从0x02内存单元开始再加上0x03内存单元共两个字节的数据传送给ax，因为ax是16位寄存器，也就是2字节。</p></blockquote><blockquote><p>而通用寄存器之间的传送可以不用修饰符，但是保证2个寄存器宽度一致，mov ax,bx 是可以的，mov cx,dh 就不对了，cx是16位的，而dh是8位的，两个寄存器宽度不一致。</p></blockquote><blockquote><p>而段寄存器与通用寄存器之间的mov也是同理，必须保证宽度一致。</p></blockquote><h3 id="内存分段" tabindex="-1"><a class="header-anchor" href="#内存分段" aria-hidden="true">#</a> 内存分段</h3><p>内存在我们学习汇编或者C语言之类的高级语言，其重要性无与伦比。</p><p>我们目前处于研究8086的阶段，先把这个相对简单的CPU研究明白，再去研究更高级的不可冒进。</p><p>8086有20根地址线，寻址空间是2的二十次方，共1MB。而8086的寄存器都是16位的，寻址能力是2的16次方共64KB，这1MB的地址空间，一个16位寄存器搞不定。1个搞不定就用2个，所以就有了段地址：偏移地址地址的寻址方式。</p><p>1MB=16x64KB，也就是说1MB分成16份，如果每一份都是64KB，用1个16位的寄存器就可以寻址每一个内存单元了， 16分是2的4次方可以用4个二进制表示。</p><p>20根地址线，1个16位寄存器，再加4位就是20位了。</p><p>8086给了个方法，给你 2个 16位寄存器，一个是段寄存器，一个是偏移地址寄存器，段寄存器的作用是标记内存分段，偏移地址寄存器的作用是标记段内的位置。</p><img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202208121301749.jpg" alt="A04F3335-AF11-4506-AF96-56195F642124" style="zoom:33%;"><p>为什么要左移4位？也就是乘以16？</p><ul><li>比如999 和 999 ，3位数相加结果最多也就才 4 位数而已，也就是说n位数的最大值 相加的到的结果最多也就n+1位数。</li><li>所以16位的段寄存器，和16 位的偏移寄存器相加 最多得到17位而已，而1MB需要二十位，17位是远远不够的。</li><li>所以我们把段地址以16（也就是左移4位）就有20位了，再加上偏移地址，就可以寻址完1MB了。</li></ul><p>8086/8088 CPU中的寄存器只有16位，如果采用它们直接寻址，则寻址能力势必限制在64 KB范围内，而采用分段组织可以较好地实现扩展CPU的寻址能力。<strong>每段的大小 最小16个字节（分65536段），最大可达64 KB（分16段）</strong>，，不同段的组合则可寻址更大的范围。</p><ul><li><p>使程序与数据相对独立,不同存取方式的数据也相对独立。</p></li><li><p>程序：存放于代码段CS中</p></li><li><p>堆栈方式：存放于堆栈段BSS中</p></li><li><p>数据：随机方式:存放于数据段DS及附加段ES中</p></li><li><p>便于程序和数据的动态装配，从一个地方挪到另外一个地方只要更改一下段寄存器的值即可，段内偏移可以不用改变。</p></li><li><p><strong>缺点</strong>：内存地址采用分段组织增加地址计算的复杂度,降低了CPU的执行效率。</p></li></ul><p><strong>为什么最小只能划分16段？，最大65536段？</strong></p><ul><li>**最小只能划分16段？：**因为需要二十位才能寻址1MB，段地址和偏移地址相加想要得到20位寻址能力，最小需要 4位 + 16位。这时候必须要占用4位的段地址才行。每一段 64KB，16位的偏移地址就可以找到每一个字节了。</li><li>**最大65536段？：**因为段寄存器是16位的 0 ～ 65535 一共能分 65536段。每一段，16个字节，加上4位偏移地址即可找到每一个字节了。</li></ul><p>因为每个段最小是16个字节，所以每段的起始地址，一定是16的倍数。（<strong>这就是16字节对齐</strong>）</p><p>我们可以把1MB分为16、32、64、128、256、...、65536 个段。</p><ul><li>程序有大有小，所占用的数据段和代码段都不太一样。</li></ul><p>8086地址空间的物理地址只有一个，而 段地址 : 偏移地址得出的是逻辑地址，是可以有多个的， 那么一个逻辑地址可以对应多少个逻辑地址呢？</p><p>我们就拿地址空间的 0x00010地址来举例，这时距离最开始的 0x00000 的第17个字节。它的前面还有 0x00000 ~ 0x0000F 共16个字节。</p><p>​ 我们先把1MB分16分，每一份64KB，那么 0x00010这个地址，就在第一个段内，用段地址 : 偏移地址的表示方法 就是 0x0000 : 0x0010 我们先把 0x0000 左移4位，得到 0x00000 再加上偏移地址 0x0010就可以得到 0x00010这个物理地址了。</p><table><thead><tr><th style="text-align:center;">段数</th><th style="text-align:center;">逻辑地址</th></tr></thead><tbody><tr><td style="text-align:center;">16</td><td style="text-align:center;">0x0000 : 0x0010</td></tr><tr><td style="text-align:center;">32</td><td style="text-align:center;">0x0000 : 0x0010</td></tr><tr><td style="text-align:center;">32768</td><td style="text-align:center;">0x0000 : 0x0010</td></tr><tr><td style="text-align:center;">65536</td><td style="text-align:center;">0x0001 : 0x0000</td></tr></tbody></table><p>分65536段时，每一段是16个字节，第一段是没办法表示的，所以段地址需要进位，加上偏移地址 0x0000 得到了第17个字节了。</p><p>把这些地址再做一次转换就可以得到物理地址了。比如：</p><ul><li><p>**分16段：**0x0000 左移4位 0x00000 加上偏移地址 0x0010 得到 0x00010 物理地址。</p></li><li><p>....</p></li><li><p>分65536段 ， 0x0001 左移4位 0x00010 加上偏移地址 0x0000 得到 0x00010 物理地址。</p></li></ul><p>总结：0x00010 这个物理地址，分别可以对应 1MB 地址空间，分成65536、32768、...、64、32、16段时，可能会对应不同的逻辑地址。分别是 0x0000 : 0x0010 以及 0x0001 : 0x0000 ，这是最简单的情况。比较复杂的是0xFFFFF 这个地址：</p><table><thead><tr><th style="text-align:center;">段数</th><th style="text-align:center;">逻辑地址</th></tr></thead><tbody><tr><td style="text-align:center;">16</td><td style="text-align:center;">0xF000 : 0xFFFF</td></tr><tr><td style="text-align:center;">32</td><td style="text-align:center;">0xf800 : 0x7FFF</td></tr><tr><td style="text-align:center;">32768</td><td style="text-align:center;">0xFFFE : 0x001F</td></tr><tr><td style="text-align:center;">65536</td><td style="text-align:center;">0xFFFF : 0x000F</td></tr></tbody></table><p><strong>注意</strong>：分段，不是用一个数字 0 ～ F来区分，段的起始地址应该是 ：0xFFFF / 某段 = 段起始地址。</p><p><strong>公式</strong>：</p><ul><li>段起始地址：段寄存器最大值 / 段数 * 第几段 = 段起始地址： <ul><li><code>65536 / 16 * 15 = 61440 = 0xF000(段起始地址)</code></li></ul></li><li>段逻辑地址：内存大小 / 段数 = 每段大小 <ul><li><code>1048576(1MB) / 16 = 65536 = 0xFFFF</code></li></ul></li></ul><h3 id="汇编地址" tabindex="-1"><a class="header-anchor" href="#汇编地址" aria-hidden="true">#</a> 汇编地址</h3><blockquote><p>8086时代不同的程序采用不同的分段策略，两个程序的不同逻辑地址可能对应相同的物理地址，程序A可能修改程序B已经保存在内存的值（游戏修改器就是这么来的）。</p><p>16位模式也称为实模式，当我们进入32位模式的时候会有一个保护模式。在保护模式下，程序不能随意更改其他程序的内存。</p><p>我们在编程的时候，mov 指令后面无论是源还是目的地操作数，只要是涉及内存访问的，都是逻辑地址。</p><p>汇编地址：我们在写Start.ams 这个程序的时候，通过 2 行代码指定了 DS（数据段）为 0b800，但是我们并没有指定CS（代码段）地址，那么CPU是怎么来找到我们程序的指令呢？</p><ul><li><p>这里的逻辑是这样的，我们写完了 Start.asm 的代码，保存成一个文件，然后使用Nasm 这个编译器把 Start.asm 编译成机器代码，好让计算机认识。</p></li><li><p>在编译的过程中，Nasm 会把 Start.asm 当成一整个代码段，里面的每一条指令，都会有一个相对于代码段头头部的偏移地址，这个偏移地址就叫汇编地址。</p></li><li><p>而编译完成后，我们把 Start.bin 文件放到虚拟机或者真机运行，这是 ROM-BIOS 程序会把Start.bin 加载到内存，具体哪个位置 一是看我们程序的大小，二是看内存的闲置空间找到合适的位置，ROM-BIOS就把Start.bin 放进去，这是后Start.bin 就在真实的物理内存里了。</p></li><li><p>而它也有了一个真实的起始物理地址，这个就给了CS，然后在执行的时候，CPU就按照</p><p>CS : IP (代码段寄存器 : 指令寄存器) 的逻辑地址去寻址，这时你就会发现，当 Start.bin 在内存中的偏移地址跟汇编地址一样，它们都是相对于程序起始位置的偏移。也就是说汇编地址等于实际的偏移地址 。</p></li><li><p><strong>汇编地址各位同学知道这个意思就行，但是内存分段的逻辑地址必须好好掌握</strong></p></li></ul><p>8086的分段机制本意是为了解决16位寄存器无法访问全部 1MB 地址空间的问题，但同时也带来了另外一个好处，就是程序重定位变得更加简单。</p><ul><li>程序重定位问题简单来说，就是你在电脑上打开了很多程序，如果在编写程序的时候，使用绝对的物理地址，比如你想让 Start.bin 加载到0x80000 这个位置，如果之前有别的程序占用了 0x80000 ，那么就会产生冲突，而有了分段机制后，ROM-BIOS或者操作系统就可以进行调度，只要给Start.bin 找一个可用的内存空间就行了。</li><li>Start.bin 内部都是使用相对程序头的逻辑地址 ，所以无论加载到内存哪个段，代码都是可以运行的。</li></ul><img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202208221908558.jpg" alt="v2-b86cd4443bdb6cd21813af89bf2007e9_1440w" style="zoom:80%;"></blockquote><h3 id="汇编调试-bochs" tabindex="-1"><a class="header-anchor" href="#汇编调试-bochs" aria-hidden="true">#</a> 汇编调试 Bochs</h3><ol><li><strong>MacOS安装bochs和sdl</strong></li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>brew <span class="token function">install</span> bochs
brew <span class="token function">install</span> sdl
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><p><strong>创建虚拟硬盘</strong></p><ol><li>首先进入使用cd命令进入项目目录</li><li>输入<code>bximage</code>命令</li></ol></li></ol><img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202209080026063.png" alt="3bdda1dc60724894b599aeb109cb6fdc" style="zoom:50%;"><ol start="3"><li><p><strong>编写汇编代码，代码如下，存为boot.asm文件</strong></p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>	org 07c00h
	mov ax, cs
	mov ds, ax
	mov es, ax
	call DispStr
	jmp $
DispStr:
	mov ax, BootMessage
	mov bp, ax
	mov cx, 16
	mov ax, 01301h
	mov bx, 000ch
	mov dl, 0
	int 10h
	ret
BootMessage:	db &quot;Hello OS World&quot;
times 510 - ($-$$) db 0
dw 0xaa55
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>编译汇编代码</strong></p><ol><li>我们使用nasm来汇编boot.asm生成 boot.bin 的二进制代码。首先需要安装nasm</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>brew <span class="token function">install</span> nasm
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="2"><li>进入项目目录，并使用如下命令生成boot.bin文件（命令执行后该文件会出现在项目目录下）</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>nasm boot.asm <span class="token parameter variable">-o</span> boot.bin
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p><strong>将编译后的代码写入虚拟硬盘中</strong></p></li></ol><pre><code> 1.   使用如下命令，if（代表输入文件）和of（代表输出设备）后面的内容一定要与上述步骤对应起来

      ```shell
      dd if=boot.bin of=a.img bs=512 count=1 conv=notrunc
      ```

 2.   注意boot.bin和a.img文件必须都在项目目录下
</code></pre><ol start="7"><li><p><strong>配置启动信息</strong></p><ol><li><p>找到bochs安装目录下的配置路径：/usr/local/Cellar/bochs/2.7/share/doc/bochs/bochsrc-sample.txt</p><blockquote><p>关于配置路径问题，标志就是找到bochsrc-sample.txt该文件。不同的电脑、不同的bochs版本可能会有区别。</p></blockquote></li><li><p>拷贝bochsrc-sample.txt文件，存放在项目目录下，加入如下配置</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>romimage: <span class="token assign-left variable">file</span><span class="token operator">=</span><span class="token variable">$BXSHARE</span>/BIOS-bochs-latest 

vgaromimage: <span class="token assign-left variable">file</span><span class="token operator">=</span><span class="token variable">$BXSHARE</span>/VGABIOS-lgpl-latest

floppya: <span class="token assign-left variable">1_44</span><span class="token operator">=</span>a.img, <span class="token assign-left variable">status</span><span class="token operator">=</span>inserted

<span class="token comment"># 从软盘启动</span>
boot: floppy
<span class="token comment">#输出日志</span>
log: bochsout.txt

<span class="token comment"># 置鼠标不可用</span>
mouse: <span class="token assign-left variable">enabled</span><span class="token operator">=</span><span class="token number">0</span>
<span class="token comment">#键盘配置</span>
keyboard: <span class="token assign-left variable">keymap</span><span class="token operator">=</span><span class="token comment">#$BXSHARE/keymaps/x11-pc-us.map</span>
<span class="token comment">#内存容量</span>
megs: <span class="token number">32</span>

<span class="token comment">#使用GUI界面</span>
display_library: sdl2

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol></li><li><p><strong>启动bochs</strong></p><ol><li>使用cd命令进入项目目录</li><li>输入启动命令：</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>bochs <span class="token parameter variable">-f</span> bochsrc-sample.txt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ol><pre><code>3. &lt;img src=&quot;https://cxrs.oss-cn-shenzhen.aliyuncs.com/202209080034319.png&quot; alt=&quot;image-20220908003409241&quot; style=&quot;zoom: 33%;&quot; /&gt;
4. 回车选择6 开始调试，或者输入其他数字。
</code></pre><h3 id="bochs基本用法" tabindex="-1"><a class="header-anchor" href="#bochs基本用法" aria-hidden="true">#</a> Bochs基本用法</h3><p><strong>命令</strong></p><ul><li><p>s</p><ul><li>单步调试，bochs会执行一条指令</li></ul></li><li><p>b</p><ul><li>打断点，后面跟内存地址</li><li>例如：编译好start.bin 程序，会被加载到内存0x7c00位置 <code>b 0x7c00</code></li><li>这时候还没有执行，我们需要输入再输入c（continue，继续）</li></ul></li><li><p>c</p><ul><li>继续</li></ul></li><li><p>r</p><ul><li>查看通用寄存器</li></ul></li><li><p>sreg</p><ul><li>查看段寄存器</li></ul></li><li><p>xp /nuf addr</p><ul><li><p>查看物理内存</p></li><li><p>n 多少个字节</p></li><li><p>u 单位（unit，单位的意思）</p><ul><li>b 1字节</li><li>h 2字节</li><li>w 4字节</li><li>g 8字节</li></ul></li><li><p>f 格式</p><ul><li>x 十六进制</li><li>d 十进制</li><li>u 无符号十进制</li><li>o 八进制</li><li>t 二进制</li></ul></li><li><p>addr （address，地址）</p></li><li><p>例：</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>mov ax, 0x7c00
mov ds, ax
mov bx, 0x353637
mov byte [0xf1], &#39;H&#39; # ASCII : 48
mov byte [0xf2], 0x3839
jmp $
times 510 - ($ - $$) db 0
db 0x55, 0xaa
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看0x7c0f1、0x7c0f2的内容，这两个地址是 DS : IP 逻辑地址转换而来</p><img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202209080333224.png" alt="QQ20220908-033303@2x" style="zoom:25%;"><p>可以看到高位会被舍去</p></li></ul></li><li><p>q</p><ul><li>退出调试</li></ul></li></ul><img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202209080049106.png" alt="QQ20220908-004937@2x" style="zoom:33%;"><p>一般流程：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>设置断点 -&gt; 继续 -&gt; 单步调试 -&gt; 跳过/结束
b 0xxx  -&gt; c   -&gt; s       -&gt; c
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></div><!--[--><!--]--></div><footer class="page-meta"><div class="meta-item edit-link"><a class="external-link meta-item-label" href="https://github.com/GerryDush/edit/main/note/Operating System.md" rel="noopener noreferrer" target="_blank" aria-label="Edit this page"><!--[--><!--]--> Edit this page <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: Tianya-68@qq.com">“Mortal-Tianya”</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/my-vuepress-blog/assets/app-521e935c.js" defer></script>
  </body>
</html>
