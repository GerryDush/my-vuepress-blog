import{_ as o,r as l,o as t,c as r,d as n,e as a,b as e,a as i}from"./app-521e935c.js";const c={},p=n("h1",{id:"kernel",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#kernel","aria-hidden":"true"},"#"),a(" Kernel")],-1),d=n("p",null,"我非常喜欢造轮子，本文的目标是从了解 CPU 到 Linux 的全过程，到给各种各样的淘汰设备移植 Linux 移植或编写它们的驱动，即使可能会烂尾，仅作为爱好。",-1),u=n("p",null,[a("因为本人文笔非常差，在网上找到一些优秀的文章（"),n("strong",null,"特别感谢原作者"),a("），我很清楚我写不出比原文更优秀更易懂的文章，所以我可能会直接复制粘贴，甚至全文。如有侵权请联系"),n("a",{href:"mailto:liu_yupei@foxmail.com"},"我"),a("。")],-1),b={id:"转载-arm-soc-启动过程",tabindex:"-1"},m=n("a",{class:"header-anchor",href:"#转载-arm-soc-启动过程","aria-hidden":"true"},"#",-1),h={href:"http://1.117.24.237/2021/11/08/arm-soc-boot.html",target:"_blank",rel:"noopener noreferrer"},v=i('<h3 id="启动过程概览" tabindex="-1"><a class="header-anchor" href="#启动过程概览" aria-hidden="true">#</a> 启动过程概览</h3><p><code>BootRom –&gt; SPL –&gt; U-Boot –&gt; Kernel –&gt; File System –&gt; init</code></p><h3 id="bootrom" tabindex="-1"><a class="header-anchor" href="#bootrom" aria-hidden="true">#</a> BootRom</h3><p>BootROM是固化在SOC内部（在片内的一小块norflash上，容量很小，只读）的一段代码，是芯片设计时候的一个重点环节。</p><p>CPU 上电读取 BootRom 里面的代码并执行，这段代码负责读取 flash 的前面部分数据（U-Boot 的前半段，也称 SPL，一般 4K）到 SRAM。</p><p>U-Boot（一般几百K） 比 Kernel 小不少，但是 ROM（一般十几K） 仍然存不下。这时候又想出了一个办法，在 ROM（称为 BootRom） 中存放一段固定的代码，这段代码的作用是将 flash 中的 U-Boot 拷贝到 SRAM 中运行，为什么不是拷贝到 DDR 中运行呢？因为 DDR 需要初始化才能使用，初始化之前无法使用。不过 U-Boot 虽小， SRAM 更小，存放不下整个 U-Boot。这个时候就采取了一种折中的做法，拷贝 U-Boot 的前面一段代码（SPL）到 SRAM 中运行，这段代码赶紧将 DDR 初始化好，好让完整的 U-Boot 得以运行。</p><h3 id="spl" tabindex="-1"><a class="header-anchor" href="#spl" aria-hidden="true">#</a> SPL</h3><p>Secondary Program Loader，第二阶段程序加载器。SPL 负责初始化 DDR，然后将 U-Boot 的后半段加载到 DDR RAM，执行 U-Boot，U-Boot 负责从 flash 读取 Kernel 到 RAM，然后执行 Kernel，Kernel 最终执行 init 程序，从而 fork 出众多的用户进程。</p><h3 id="u-boot" tabindex="-1"><a class="header-anchor" href="#u-boot" aria-hidden="true">#</a> U-Boot</h3><p>为什么要有 U-Boot 呢？芯片上电直接运行 Kernel 不就行了？我们来看看可行不，刚上电时，CPU 只能从 ROM 或 SRAM 中读取数据，而 ROM 的存储空间较小，难以放下整个 Kernel。flash 能够放下整个 Kernel，但是这些 flash（ SPI flash、nand flash）一般都需要相应的驱动，CPU 才能读取它们。看起来是无解了：CPU 能直接读取的介质存不下 Kernel；能存储 Kernel 的flash，刚上电时 CPU 又无法直接读取。这时候想出了一个办法，那就是使用 U-Boot，由 U-Boot 来提供硬件的驱动，从 flash 中读取 Kernel 放入 RAM 中运行。</p><h3 id="kernel-1" tabindex="-1"><a class="header-anchor" href="#kernel-1" aria-hidden="true">#</a> Kernel</h3><p>为什么要有 Kernel 呢？直接运行用户程序不就行了？答案是直接运行用户程序较容易发生错误。当有多个用户程序同时运行时，如果同时有多个进程操作同一个硬件，很可能会导致硬件异常。最简单的是读写的例子，A 进程刚向 a 地址中写了一个数据，用作暂存，准备马上读走，很不幸的是，紧接着 B 又向 a 地址中写入了一个数据，导致 A 之前存放的数据就永远地消失了。。。所以，必须要让多个进程有所联系（调度也好，进程之间交流也好），保证同时只有一个进程操作硬件。操作系统就能提供这个环境，而 Kernel 又是操作系统的核心。</p><h3 id="file-system" tabindex="-1"><a class="header-anchor" href="#file-system" aria-hidden="true">#</a> File System</h3><p>为什么要有文件系统呢？上面我们讲到，嵌入式的最终目的是应用，也就是一个个应用程序。那么这些应用程序存放在哪呢？当然是磁盘上，如果我们不把磁盘格式化出文件系统，就直接以二进制数值的形式一字节一字节地存放在磁盘里，可行吗？当然是可行的，不过，这种存放方式对应用程序的存取、管理几乎是灾难。文件系统能够给读写、管理带来极大的便利，所以，文件系统的存在还是很有必要的。</p><h3 id="init-进程" tabindex="-1"><a class="header-anchor" href="#init-进程" aria-hidden="true">#</a> init 进程</h3><p>为什么需要 init进程？嵌入式的定义，第一句话就是：以应用为中心。所以，整个嵌入式系统的最终目的是运行应用，而这里所说的应用在 Linux 中就是指用户空间的进程。那么，用户空间的进程总得有人来创建吧，总得有人来 fork 生出新程序吧，单应用到底不容易实现较复杂的功能。init 就扛起了这面大旗，成为了所有用户空间进程的祖先进程。</p><h3 id="整体流程" tabindex="-1"><a class="header-anchor" href="#整体流程" aria-hidden="true">#</a> 整体流程</h3><p>最终就形成了这种局面：CPU 上电读取 bootRom 里面的代码并执行，这段代码负责读取 flash 的前面部分数据（uboot 的前半段，也称 SPL，一般 4K）到 SRAM，SPL 负责初始化 DDR，然后将 uboot 的后半段加载到 DDR RAM，执行 uboot，uboot 负责从 flash 读取 Kernel 到 RAM，然后执行 Kernel，Kernel 最终执行 init 程序，从而 fork 出众多的用户进程。</p><hr><h3 id="参考" tabindex="-1"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h3>',20),k={href:"https://zhuanlan.zhihu.com/p/265672867",target:"_blank",rel:"noopener noreferrer"},f={href:"https://zhuanlan.zhihu.com/p/129102939",target:"_blank",rel:"noopener noreferrer"},g={href:"https://blog.csdn.net/yafeixi/article/details/82992681",target:"_blank",rel:"noopener noreferrer"},x={href:"https://blog.csdn.net/q123456789098/article/details/47086533",target:"_blank",rel:"noopener noreferrer"},_=n("hr",null,null,-1),y=n("h3",{id:"本章节声明",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#本章节声明","aria-hidden":"true"},"#"),a(" 本章节声明")],-1),S={href:"http://1.117.24.237/2021/11/08/arm-soc-boot.html",target:"_blank",rel:"noopener noreferrer"},M=n("a",{href:"mailto:liu_yupei@foxmail.com"},"我",-1),B=i(`<hr><br><br><br><h2 id="qemu-运行-u-boot-并启动-linux" tabindex="-1"><a class="header-anchor" href="#qemu-运行-u-boot-并启动-linux" aria-hidden="true">#</a> QEMU 运行 U-Boot 并启动 Linux</h2><p>我认为从U-Boot到启动Linux的过程非常复杂，在学习一个技术之前，不知道它的作用以及流程对于我来说非常痛苦，所以我找了很多文章，最后总结出本章节的从零运行Linux的过程。</p><h3 id="环境准备" tabindex="-1"><a class="header-anchor" href="#环境准备" aria-hidden="true">#</a> 环境准备</h3><p>为了避免出现各种环境问题导致的错误，建议参考本文的开发环境。</p><h4 id="个人开发环境" tabindex="-1"><a class="header-anchor" href="#个人开发环境" aria-hidden="true">#</a> 个人开发环境</h4><ul><li>宿主机：<code>Ubuntu 23.04 （Lunar Lobster）</code></li><li>开发板：<code>Qemu + vexpress-a9</code></li><li>编译器：<code>arm-linux-gnueabihf-gcc</code></li></ul><p><strong>目标运行环境</strong></p><ul><li><code>QEMU 7.2.0</code></li><li><code>U-Boot 2023.10</code></li><li><code>BusyBox 1.36.1</code></li><li><code>Linux 6.5.5</code></li></ul><h4 id="编译环境安装" tabindex="-1"><a class="header-anchor" href="#编译环境安装" aria-hidden="true">#</a> 编译环境安装</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">apt</span> <span class="token function">install</span> <span class="token function">make</span>
<span class="token function">apt</span> <span class="token function">install</span> bison
<span class="token function">apt</span> <span class="token function">install</span> flex
<span class="token function">apt</span> <span class="token function">install</span> libncurses-dev
<span class="token function">apt</span> <span class="token function">install</span> libssl-dev
<span class="token function">apt</span> <span class="token function">install</span> <span class="token function">bc</span>
<span class="token function">apt</span> <span class="token function">install</span> gcc-arm-linux-gnueabihf
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="qemu" tabindex="-1"><a class="header-anchor" href="#qemu" aria-hidden="true">#</a> QEMU</h4><p>QEMU是一款免费开源且跨平台的虚拟机，可以虚拟各种架构的处理器。</p><h4 id="第一步-下载并安装qemu" tabindex="-1"><a class="header-anchor" href="#第一步-下载并安装qemu" aria-hidden="true">#</a> 第一步：下载并安装QEMU</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">apt</span> <span class="token function">install</span> qemu-system
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="第二步-选择一款arm" tabindex="-1"><a class="header-anchor" href="#第二步-选择一款arm" aria-hidden="true">#</a> 第二步：选择一款arm</h4><p>装好后可以通过以下命令qemu支持哪些arm处理器(开发板)：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>root@Ubuntu-arm64:~<span class="token comment"># qemu-system-arm -M help</span>
Supported machines are:
akita                Sharp SL-C1000 <span class="token punctuation">(</span>Akita<span class="token punctuation">)</span> PDA <span class="token punctuation">(</span>PXA270<span class="token punctuation">)</span>
<span class="token punctuation">..</span>.
tosa                 Sharp SL-6000 <span class="token punctuation">(</span>Tosa<span class="token punctuation">)</span> PDA <span class="token punctuation">(</span>PXA255<span class="token punctuation">)</span>
verdex               Gumstix Verdex <span class="token punctuation">(</span>PXA270<span class="token punctuation">)</span>
versatileab          ARM Versatile/AB <span class="token punctuation">(</span>ARM926EJ-S<span class="token punctuation">)</span>
versatilepb          ARM Versatile/PB <span class="token punctuation">(</span>ARM926EJ-S<span class="token punctuation">)</span>
vexpress-a15         ARM Versatile Express <span class="token keyword">for</span> Cortex-A15
vexpress-a9          ARM Versatile Express <span class="token keyword">for</span> Cortex-A9
<span class="token punctuation">..</span>.
root@Ubuntu-arm64:~<span class="token comment"># </span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>选中自己喜欢的“硬件”环境后，理论上就可以“上电”了，不过且慢——操作系统还没装呢！所以接下来很重要的一步就是制作自己的Linux系统镜像。</p><h3 id="配置并编译u-boot" tabindex="-1"><a class="header-anchor" href="#配置并编译u-boot" aria-hidden="true">#</a> 配置并编译U-Boot</h3><p>U-Boot（Universal Bootloader）是一个开源的引导加载程序，广泛用于嵌入式系统中。它的主要作用是在启动时初始化硬件，加载操作系统内核到内存中，并启动操作系统。</p>`,24),C={href:"https://github.com/u-boot/u-boot/releases/tag/v2023.10",target:"_blank",rel:"noopener noreferrer"},R=i(`<p>进入U-Boot源码目录，在终端中输入，使用vexpress-a9的作为默认配置</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">make</span> <span class="token assign-left variable">ARCH</span><span class="token operator">=</span>arm <span class="token assign-left variable">CROSS_COMPILE</span><span class="token operator">=</span>arm-linux-gnueabi- vexpress_ca9x4_defconfig
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>进入菜单配置（通过上下左右、空格、ESC等按键控制），再具体更改一些配置</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">make</span> <span class="token assign-left variable">ARCH</span><span class="token operator">=</span>arm <span class="token assign-left variable">CROSS_COMPILE</span><span class="token operator">=</span>arm-linux-gnueabi- menuconfig
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>进入 <code>menuconfig</code> ，在之中找到 <code>Boot options</code> ，并空格选中 <code>Enable a default value of bootcmd</code> 并设置 <code>bootcmd value</code> 为</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>load mmc <span class="token number">0</span>:1 0x70008000 zImage<span class="token punctuation">;</span>load mmc <span class="token number">0</span>:1 0x70c08000 vexpress-v2p-ca9.dtb<span class="token punctuation">;</span>bootz 0x70008000 - 0x70c08000<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上述代码为U-Boot三行命令，以分号分割，分别从 <code>mmc 0:1</code> （第一个分区）加载了:</p><ul><li><code>zImage</code> 内核镜像到内存</li><li>加载设备树到内存</li><li>并且从内存引导启动 <code>zImage</code>。</li></ul><p>选中 <code>Enable boot arguments</code> 设置，并设置 <code>Boot arguments</code>为</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token assign-left variable">console</span><span class="token operator">=</span>tty0 <span class="token assign-left variable">console</span><span class="token operator">=</span>ttyAMA0,38400n8 <span class="token assign-left variable">root</span><span class="token operator">=</span>/dev/mmcblk0p2 earlyprintk rw
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>配置完后保存退出。</p><blockquote><p>实测，以上配置可能无法起作用，导致 u-boot 无法启动内核，解决方法： 编辑 <code>u-boot-2023.10/include/configs/vexpress_common.h</code> ，找到 <code>CFG_EXTRA_ENV_SETTINGS</code> 宏定义，把这一段宏定义全部删除即可生效。</p></blockquote><p>配置完后进行U-Boot的编译。在终端中输入：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">make</span> <span class="token assign-left variable">ARCH</span><span class="token operator">=</span>arm <span class="token assign-left variable">CROSS_COMPILE</span><span class="token operator">=</span>arm-linux-gnueabihf- <span class="token parameter variable">-j10</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其中 <code>-j10</code> 指明了多线程编译。可以提升编译速度。</p><p>编译完成后将会在U-Boot目录出现U-Boot文件。</p><h3 id="编译-linux-内核" tabindex="-1"><a class="header-anchor" href="#编译-linux-内核" aria-hidden="true">#</a> 编译 Linux 内核</h3>`,17),U={href:"https://www.kernel.org/",target:"_blank",rel:"noopener noreferrer"},L=i(`<p>进入Linux内核源码目录。在Shell中执行</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">make</span> <span class="token assign-left variable">ARCH</span><span class="token operator">=</span>arm <span class="token assign-left variable">CROSS_COMPILE</span><span class="token operator">=</span>arm-linux-gnueabihf- vexpress_defconfig
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如需更改配置（本文未修改）</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">make</span> <span class="token assign-left variable">ARCH</span><span class="token operator">=</span>arm <span class="token assign-left variable">CROSS_COMPILE</span><span class="token operator">=</span>arm-linux-gnueabihf- menuconfig
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>接下来进行编译。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">make</span> <span class="token assign-left variable">ARCH</span><span class="token operator">=</span>arm <span class="token assign-left variable">CROSS_COMPILE</span><span class="token operator">=</span>arm-linux-gnueabihf- <span class="token parameter variable">-j10</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>编译完成后会在 <code>arch/arm/boot</code> 目录中生成 <code>zImage</code> ，在 <code>arch/arm/boot/dtb</code> 目录中找到设备树文件 <code>vexpress-v2p-ca9.dtb</code></p><h3 id="构建文件系统" tabindex="-1"><a class="header-anchor" href="#构建文件系统" aria-hidden="true">#</a> 构建文件系统</h3><h4 id="创建空白磁盘镜像并分区" tabindex="-1"><a class="header-anchor" href="#创建空白磁盘镜像并分区" aria-hidden="true">#</a> 创建空白磁盘镜像并分区</h4><p>创建一个256M的空白磁盘镜像 sd.img</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/dev/zero <span class="token assign-left variable">of</span><span class="token operator">=</span>sd.img <span class="token assign-left variable">bs</span><span class="token operator">=</span>1M <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">256</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>安装 <code>fdisk</code></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">apt</span> <span class="token function">install</span> <span class="token function">fdisk</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>对其进行分区</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">fdisk</span> sd.img
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="新建一个32m的-boot-分区" tabindex="-1"><a class="header-anchor" href="#新建一个32m的-boot-分区" aria-hidden="true">#</a> 新建一个32M的 <code>boot</code> 分区</h4><ul><li><code>Command (m for help): </code> 输入 <code>n</code> 新建分区</li><li><code>Select (default p): </code> 默认是主分区，直接回车或输入 <code>p</code></li><li><code>Partition number (1-4, default 1): </code> 分区号，默认或 <code>1</code></li><li><code>First sector (2048-524287, default 2048): </code> 起始扇区，默认</li><li><code>Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-524287, default 524287): </code> 结束扇区，输入 <code>+32M</code></li><li><code>Command (m for help): </code> 输入 <code>w</code> 保存</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>root@Ubuntu-arm64:~/hello<span class="token comment"># fdisk sd.img</span>

Welcome to <span class="token function">fdisk</span> <span class="token punctuation">(</span>util-linux <span class="token number">2.38</span>.1<span class="token punctuation">)</span>.
Changes will remain <span class="token keyword">in</span> memory only, <span class="token keyword">until</span> you decide to <span class="token function">write</span> them.
Be careful before using the <span class="token function">write</span> command.

Device does not contain a recognized partition table.
Created a new DOS <span class="token punctuation">(</span>MBR<span class="token punctuation">)</span> disklabel with disk identifier 0xbb942f88.

Command <span class="token punctuation">(</span>m <span class="token keyword">for</span> <span class="token builtin class-name">help</span><span class="token punctuation">)</span>: n
Partition <span class="token builtin class-name">type</span>
   p   primary <span class="token punctuation">(</span><span class="token number">0</span> primary, <span class="token number">0</span> extended, <span class="token number">4</span> <span class="token function">free</span><span class="token punctuation">)</span>
   e   extended <span class="token punctuation">(</span>container <span class="token keyword">for</span> logical partitions<span class="token punctuation">)</span>
Select <span class="token punctuation">(</span>default p<span class="token punctuation">)</span>: 

Using default response p.
Partition number <span class="token punctuation">(</span><span class="token number">1</span>-4, default <span class="token number">1</span><span class="token punctuation">)</span>: 
First sector <span class="token punctuation">(</span><span class="token number">2048</span>-524287, default <span class="token number">2048</span><span class="token punctuation">)</span>: 
Last sector, +/-sectors or +/-size<span class="token punctuation">{</span>K,M,G,T,P<span class="token punctuation">}</span> <span class="token punctuation">(</span><span class="token number">2048</span>-524287, default <span class="token number">524287</span><span class="token punctuation">)</span>: +32M

Created a new partition <span class="token number">1</span> of <span class="token builtin class-name">type</span> <span class="token string">&#39;Linux&#39;</span> and of size <span class="token number">32</span> MiB.

Command <span class="token punctuation">(</span>m <span class="token keyword">for</span> <span class="token builtin class-name">help</span><span class="token punctuation">)</span>: w
The partition table has been altered.
Syncing disks.

root@Ubuntu-arm64:~/hello<span class="token comment"># </span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="剩余空间-新建一个存放根文件系统-rootfs-的分区" tabindex="-1"><a class="header-anchor" href="#剩余空间-新建一个存放根文件系统-rootfs-的分区" aria-hidden="true">#</a> 剩余空间，新建一个存放根文件系统（<code>rootfs</code>）的分区：</h4><ul><li><code>Command (m for help): </code> 输入 <code>n</code> 新建分区</li><li><code>Select (default p): </code> 默认</li><li><code>Partition number (1-4, default 1): </code> 默认</li><li><code>First sector (2048-524287, default 2048): </code> 默认</li><li><code>Last sector, +/-sectors or +/-size{K,M,G,T,P} (2048-524287, default 524287): </code> 默认</li><li><code>Command (m for help): </code> 输入 <code>w</code> 保存</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>root@Ubuntu-arm64:~/hello<span class="token comment"># fdisk sd.img</span>

Welcome to <span class="token function">fdisk</span> <span class="token punctuation">(</span>util-linux <span class="token number">2.38</span>.1<span class="token punctuation">)</span>.
Changes will remain <span class="token keyword">in</span> memory only, <span class="token keyword">until</span> you decide to <span class="token function">write</span> them.
Be careful before using the <span class="token function">write</span> command.

Command <span class="token punctuation">(</span>m <span class="token keyword">for</span> <span class="token builtin class-name">help</span><span class="token punctuation">)</span>: n
Partition <span class="token builtin class-name">type</span>
   p   primary <span class="token punctuation">(</span><span class="token number">1</span> primary, <span class="token number">0</span> extended, <span class="token number">3</span> <span class="token function">free</span><span class="token punctuation">)</span>
   e   extended <span class="token punctuation">(</span>container <span class="token keyword">for</span> logical partitions<span class="token punctuation">)</span>
Select <span class="token punctuation">(</span>default p<span class="token punctuation">)</span>: 

Using default response p.
Partition number <span class="token punctuation">(</span><span class="token number">2</span>-4, default <span class="token number">2</span><span class="token punctuation">)</span>: 
First sector <span class="token punctuation">(</span><span class="token number">67584</span>-524287, default <span class="token number">67584</span><span class="token punctuation">)</span>: 
Last sector, +/-sectors or +/-size<span class="token punctuation">{</span>K,M,G,T,P<span class="token punctuation">}</span> <span class="token punctuation">(</span><span class="token number">67584</span>-524287, default <span class="token number">524287</span><span class="token punctuation">)</span>: 

Created a new partition <span class="token number">2</span> of <span class="token builtin class-name">type</span> <span class="token string">&#39;Linux&#39;</span> and of size <span class="token number">223</span> MiB.

Command <span class="token punctuation">(</span>m <span class="token keyword">for</span> <span class="token builtin class-name">help</span><span class="token punctuation">)</span>: w
The partition table has been altered.
Syncing disks.

root@Ubuntu-arm64:~/hello<span class="token comment">#</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="使用回环设备挂载img并格式化虚拟磁盘" tabindex="-1"><a class="header-anchor" href="#使用回环设备挂载img并格式化虚拟磁盘" aria-hidden="true">#</a> 使用回环设备挂载img并格式化虚拟磁盘</h4><p>挂载所有分区</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>losetup <span class="token parameter variable">-fP</span> sd.img
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>安装fatfs软件包</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">apt</span> <span class="token function">install</span> dosfstools
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>格式化 <code>boot</code> 分区为fat32</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">mkfs</span> <span class="token parameter variable">-t</span> fat /dev/loop0p1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>格式化 <code>rootfs</code> 分区为 ext4</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mkfs.ext4 /dev/loop0p2 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>创建两个目录，用于挂载分区，并写入文件</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">mkdir</span> boot rootfs
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>挂载 <code>boot</code> 和 <code>rootfs</code>分区</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">mount</span> /dev/loop0p1 boot
<span class="token function">mount</span> /dev/loop0p2 rootfs
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>将zImage内核镜像和设备树文件复制到 <code>boot</code> 分区目录中</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mv /root/hello/linux-6.5.5/arch/arm/boot/dts/arm/zImage ./boot/
mv /root/hello/linux-6.5.5/arch/arm/boot/dts/arm/vexpress-v2p-ca9.dtb ./boot/
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在 <code>rootfs</code> 分区需要构建文件系统，可以使用buildroot或者使用busybox自己构建。这里演示如何使用busybox构建一个简单可用的文件系统.</p><h3 id="编译busybox" tabindex="-1"><a class="header-anchor" href="#编译busybox" aria-hidden="true">#</a> 编译BusyBox</h3><p>BusyBox 是一个开源的、精简的 Linux 工具箱，旨在为嵌入式系统和小型系统提供小巧但功能齐全的工具。BusyBox 将许多标准的 Unix 工具集成到一个单一的可执行文件中，通过命令行界面提供了一系列的命令和工具。</p>`,39),w={href:"https://busybox.net/",target:"_blank",rel:"noopener noreferrer"},A=i(`<p>进入busybox的源码目录，在Shell中输入</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">make</span> <span class="token assign-left variable">ARCH</span><span class="token operator">=</span>arm <span class="token assign-left variable">CROSS_COMPILE</span><span class="token operator">=</span>arm-linux-gnueabihf- menuconfig
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>进入menuconfig，在菜单中选择busybox包含的功能，配置完毕后保存退出。本文没有做任何修改。</p><p>编译</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">make</span> <span class="token assign-left variable">ARCH</span><span class="token operator">=</span>arm <span class="token assign-left variable">CROSS_COMPILE</span><span class="token operator">=</span>arm-linux-gnueabihf- <span class="token parameter variable">-j10</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>安装busybox到./_install目录</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">make</span> <span class="token assign-left variable">ARCH</span><span class="token operator">=</span>arm <span class="token assign-left variable">CROSS_COMPILE</span><span class="token operator">=</span>arm-linux-gnueabihf- <span class="token function">install</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>把 BusyBox 生成的文件，复制到 <code>rootfs</code> 分区</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">cp</span> <span class="token parameter variable">-r</span> busybox-1.36.1/_install/* ./rootfs/
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="制作根文件系统rootfs" tabindex="-1"><a class="header-anchor" href="#制作根文件系统rootfs" aria-hidden="true">#</a> 制作根文件系统rootfs</h4><p>busybox已经生成了linux常用的一些命令和简单的目录结构，现在还差两个东西：</p><ul><li>busybox的命令执行是依赖于交叉编译工具的动态库的，所以要把动态库放入rootfs</li><li>需要给文件系统一些默认的设备描述符，否则你想让它往哪输出</li></ul><p>拷贝gcc动态库</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">cp</span> <span class="token parameter variable">-P</span> /usr/arm-linux-gnueabihf/lib/*.so* ./rootfs/lib/
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>创建设备目录以及4个tty终端和调试串口</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">mkdir</span> rootfs/dev <span class="token comment"># 创建设备描述符目录</span>
<span class="token keyword">for</span> <span class="token for-or-select variable">i</span> <span class="token keyword">in</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token keyword">do</span> <span class="token function">sudo</span> <span class="token function">mknod</span> rootfs/dev/tty<span class="token variable">$i</span> c <span class="token number">4</span> <span class="token variable">$i</span><span class="token punctuation">;</span> <span class="token keyword">done</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="使用qemu模拟系统运行" tabindex="-1"><a class="header-anchor" href="#使用qemu模拟系统运行" aria-hidden="true">#</a> 使用QEMU模拟系统运行</h3><p>使用 QEMU 模拟 ARM 架构的 vexpress-a9 开发板，并加载 U-Boot 作为内核（kernel）。它还指定了一块 SD 卡镜像 sd.img 作为存储设备，以及分配了 512MB 的内存。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>qemu-system-arm <span class="token parameter variable">-M</span> vexpress-a9 <span class="token parameter variable">-m</span> 512M <span class="token parameter variable">-kernel</span> u-boot <span class="token parameter variable">-sd</span> sd.img <span class="token parameter variable">-nographic</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果不出意外，出现一段跑码，其中可能包含一些错误，但是只要您看到</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">..</span>.
Please press Enter to activate this console. 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>按 <code>Enter</code> 键即可进入 <code>Linux</code> 系统</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>~ <span class="token comment"># ls -l</span>
total <span class="token number">36</span>
drwxr-xr-x    <span class="token number">2</span> <span class="token number">0</span>        <span class="token number">0</span>             <span class="token number">4096</span> Oct  <span class="token number">6</span> <span class="token number">22</span>:26 bin
drwxr-xr-x    <span class="token number">2</span> <span class="token number">0</span>        <span class="token number">0</span>             <span class="token number">4096</span> Oct  <span class="token number">6</span> <span class="token number">22</span>:49 dev
drwxr-xr-x    <span class="token number">2</span> <span class="token number">0</span>        <span class="token number">0</span>             <span class="token number">4096</span> Oct  <span class="token number">6</span> <span class="token number">22</span>:27 lib
lrwxrwxrwx    <span class="token number">1</span> <span class="token number">0</span>        <span class="token number">0</span>               <span class="token number">11</span> Oct  <span class="token number">6</span> <span class="token number">22</span>:26 linuxrc -<span class="token operator">&gt;</span> bin/busybox
drwx------    <span class="token number">2</span> <span class="token number">0</span>        <span class="token number">0</span>            <span class="token number">16384</span> Oct  <span class="token number">6</span> <span class="token number">22</span>:08 lost+found
drwxr-xr-x    <span class="token number">2</span> <span class="token number">0</span>        <span class="token number">0</span>             <span class="token number">4096</span> Oct  <span class="token number">6</span> <span class="token number">22</span>:26 sbin
drwxr-xr-x    <span class="token number">4</span> <span class="token number">0</span>        <span class="token number">0</span>             <span class="token number">4096</span> Oct  <span class="token number">6</span> <span class="token number">22</span>:26 usr
~ <span class="token comment"># </span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="参考-1" tabindex="-1"><a class="header-anchor" href="#参考-1" aria-hidden="true">#</a> 参考</h3>`,25),P={href:"https://ixx.life/ArmLinuxDriver/chapter1/",target:"_blank",rel:"noopener noreferrer"},O={href:"https://www.bilibili.com/read/cv24172450/",target:"_blank",rel:"noopener noreferrer"},E=n("hr",null,null,-1),K=n("h3",{id:"本章节声明-1",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#本章节声明-1","aria-hidden":"true"},"#"),a(" 本章节声明")],-1),D=n("p",null,[a("本章节内容为参考列表中转载及个人总结整理，仅供个人参考学习，如有侵权请联系"),n("a",{href:"mailto:liu_yupei@foxmail.com"},"我"),a("，本人将及时删除相关内容。")],-1),z=n("hr",null,null,-1),I=n("br",null,null,-1),q=n("br",null,null,-1),T=n("br",null,null,-1);function V(H,Q){const s=l("ExternalLinkIcon");return t(),r("div",null,[p,d,u,n("h2",b,[m,a(),n("a",h,[a("转载：ARM SOC 启动过程"),e(s)])]),v,n("p",null,[n("a",k,[a("嵌入式Linux 启动流程，了解一下！"),e(s)]),a(" 一级启动、二级启动")]),n("p",null,[n("a",f,[a("嵌入式Linux 系统启动过程"),e(s)])]),n("p",null,[n("a",g,[a("U-Boot 中的spl 简单认识"),e(s)])]),n("p",null,[n("a",x,[a("基于AM335x的U-Boot/SPL 的CCS 调试"),e(s)])]),_,y,n("p",null,[a("本章节内容转载自"),n("a",S,[a("ARM SOC 启动过程"),e(s)]),a("仅供个人参考学习，如有侵权请联系"),M,a("，本人将及时删除相关内容。")]),B,n("p",null,[n("a",C,[a("下载U-Boot"),e(s)])]),R,n("p",null,[n("a",U,[a("下载"),e(s)])]),L,n("p",null,[n("a",w,[a("下载"),e(s)])]),A,n("p",null,[n("a",P,[a("嵌入式Linux驱动学习 一 环境准备"),e(s)])]),n("p",null,[n("a",O,[a("构建QEMU使用的嵌入式Linux系统"),e(s)])]),E,K,D,z,I,q,T])}const G=o(c,[["render",V],["__file","Kernel.html.vue"]]);export{G as default};
