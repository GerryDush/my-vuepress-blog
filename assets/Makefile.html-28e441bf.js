import{_ as a,o as e,c as n,a as s}from"./app-521e935c.js";const l={},i=s(`<h1 id="makefile" tabindex="-1"><a class="header-anchor" href="#makefile" aria-hidden="true">#</a> Makefile</h1><h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><p>一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile就像一个Shell脚本一样，也可以执行操作系统的命令。</p><h2 id="gcc" tabindex="-1"><a class="header-anchor" href="#gcc" aria-hidden="true">#</a> GCC</h2><h3 id="什么是gcc" tabindex="-1"><a class="header-anchor" href="#什么是gcc" aria-hidden="true">#</a> 什么是gcc</h3><blockquote><p>gcc的全称是GNU Compiler Collection，它是一个能够编译多种语言的编译器。最开始gcc是作为C语言的编译器（GNU C Compiler），现在除了c语言，还支持C++、java、Pascal等语言。gcc支持多种硬件平台。</p></blockquote><h3 id="gcc的特点" tabindex="-1"><a class="header-anchor" href="#gcc的特点" aria-hidden="true">#</a> gcc的特点</h3><ul><li>gcc是一个可移植的编译器，支持多种硬件平台。例如ARM、X86等。</li><li>gcc不仅是个本地编译器，他还能夸平台交叉编译。 <ul><li>本地编译：指的是编译出来的程序只能在本地环境运行。</li><li>交叉编译：gcc编译出来的程序能够在其他平台运行，例如嵌入式程序可以在x86上编译，在ARM上运行。</li></ul></li><li>gcc有多种语言前端，可以解析不同的语言。</li><li>gcc是按模块化设计的，可以加入新语言和新CPU架构支持。</li><li>gcc是自由软件，任何人都可以使用或修改这个软件。</li></ul><h3 id="gcc编译程序的四个过程" tabindex="-1"><a class="header-anchor" href="#gcc编译程序的四个过程" aria-hidden="true">#</a> gcc编译程序的四个过程</h3><ol><li><p>预处理 （Pre-Processing）</p><ul><li>预处理器（cpp），将头文件、宏展开（如果头文件包含了其他头文件，也被展开）。</li></ul><div class="language-makefile line-numbers-mode" data-ext="makefile"><pre class="language-makefile"><code>gcc -E hello.c -o hello.i
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>编译 （Compiling）</p><ul><li><p>首先要检查代码的规范性、是否有语法错误等，以确定代码的实际要做的工作，在检查无误后。编译器（ccl）将源代码编译成汇编代码。</p></li><li><p>gcc实际上是个工具链，在编译的时候调用不同的编译器。</p></li><li><p>例如c语言调用的编译器是ccl。</p></li></ul><div class="language-makefile line-numbers-mode" data-ext="makefile"><pre class="language-makefile"><code>gcc -S hello.i -o hello.s
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>汇编（Assembling）</p><ul><li>gcc调用汇编器（as）将汇编代码编译成 <strong>二进制可重定位目标程序</strong>。</li></ul><div class="language-makefile line-numbers-mode" data-ext="makefile"><pre class="language-makefile"><code>gcc -c hello.s -o hello.o
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>链接（Linking）</p><ul><li>链接器（ld）将程序所需要的目标文件链接成可执行文件。</li><li>例如程序中并没有定义”printf”的函数实现，且在预编译中包含进的”stdio.h”中也只有该函数的声明，而没有定义函数的实现，那么，是在哪里实现”printf”函数的呢？最后的答案是：系统把这些函数实现都被做到名为libc.so.6的库文件中去了，在没有特别指定时，gcc 会到系统默认的搜索路径”/usr/lib”下进行查找，也就是链接到libc.so.6库函数中去，这样就能实现函数”printf” 了，而这也就是链接的作用。</li><li>学过操作系统，我们知道，在源程序中地址是从0开始的，这是一个相对地址，而程序真正在内存中运行时的地址肯定不是从0开始的，而且在编写源代码的时候也不能知道程序的绝对地址，所以<strong>重定位</strong>能够<strong>将源代码的代码、变量 等定位为内存具体地址</strong>。</li></ul><div class="language-makefile line-numbers-mode" data-ext="makefile"><pre class="language-makefile"><code>gcc hello.o -o hello
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ol><p>编译流程图</p><img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/202207221533275.png" alt="image-20220722153258006" style="zoom:50%;"><h3 id="gcc常用选项" tabindex="-1"><a class="header-anchor" href="#gcc常用选项" aria-hidden="true">#</a> gcc常用选项</h3><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td>-o</td><td>产生目标文件 （ .i 、.o 、 .s 、可执行文件等）</td></tr><tr><td>-E</td><td>只运行C预编译</td></tr><tr><td>-S</td><td>产生汇编代码后停止编译</td></tr><tr><td>-c</td><td>取消链接步骤，并生成.o文件</td></tr><tr><td>-Wall</td><td>对gcc源代码有问题的地方发出警告</td></tr><tr><td>-Idir</td><td>将dir目录加入到搜索头文件的目录路径</td></tr><tr><td>-Ldir</td><td>将dir目录加入到搜索库目录路径</td></tr><tr><td>-llib</td><td>连接lib库</td></tr><tr><td>-g</td><td>在目标文件中嵌入调试信息，以便gdb之类的调试程序调试</td></tr></tbody></table><div class="language-makefile line-numbers-mode" data-ext="makefile"><pre class="language-makefile"><code>gcc -E hello.c -o hello.i   								<span class="token comment">#对hello.c文件进行预处理，生成了hello.i 文件</span>
gcc -S hello.i -o hello.s    								<span class="token comment">#对预处理文件进行编译，生成汇编文件</span>
gcc -c hello.s -o hello.o							 			<span class="token comment">#对汇编文件进行编译，生成目标文件</span>
gcc hello.o -o hello 									 			<span class="token comment">#对目标文件进行链接，生成可执行文件</span>
gcc hello.c -o hello 												<span class="token comment">#直接编译链接成可执行目标文件</span>
gcc -c hello.c 或 gcc -c hello.c -o hello.o <span class="token comment">#编译生成可重定位目标文件</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="gcc编译多个文件" tabindex="-1"><a class="header-anchor" href="#gcc编译多个文件" aria-hidden="true">#</a> gcc编译多个文件</h3><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//hello.h</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">_HELLO_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">_HELLO_H</span></span>
<span class="token keyword">void</span> <span class="token function">printHello</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//hello.c</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;hello.h&quot;</span></span>
<span class="token keyword">void</span> <span class="token function">printHello</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token comment">//main.c</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;hello.h&quot;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">printHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#编译这三个文件，可以一次编译：</span>
gcc hello.c main.c <span class="token parameter variable">-o</span> main <span class="token comment">#生成可执行文件main</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#独立编译。这样的好处是，当某个模块改变，只需要重新编译该模块即可，不需要重新编译搜索代码，节省编译时间。</span>
<span class="token comment"># -Wall 对gcc源代码有问题的地方发出警告</span>
<span class="token comment"># -c 		取消链接步骤，并生成.o文件，否则会报找不到main函数的错误，估计链接器是从main函数开始链接的</span>
gcc <span class="token parameter variable">-Wall</span> <span class="token parameter variable">-c</span> hello.c <span class="token parameter variable">-o</span> hello.o
gcc <span class="token parameter variable">-Wall</span> <span class="token parameter variable">-c</span> main.c <span class="token parameter variable">-o</span> main.o 	
gcc <span class="token parameter variable">-Wall</span> hello.o main.o <span class="token parameter variable">-o</span> main
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="使用外部库" tabindex="-1"><a class="header-anchor" href="#使用外部库" aria-hidden="true">#</a> 使用外部库</h3><blockquote><p>在使用C语言和其他语言进行程序设计的时候，我们需要头文件来提供对常数的定义和对系统及库函数调用的声明。库文件是一些预先编译好的函数集合，那些函数都是按照可重用原则编写的。它们通常由一组互相关联的可重用原则编写的，它们通常由一组互相关联的用来完成某项常见工作的函数构成。使用库的优点在于：</p><ul><li>模块化的开发</li><li>可重用性</li><li>可维护性</li></ul><p>库又可以分为静态库与动态库：</p><ul><li><p>静态库（.a）：静态库是指在我们的应用中，有一些公共代码是需要反复使用，就把这些代码编译为“库”文件；在链接步骤中，连接器将从库文件取得所需的代码，复制到生成的可执行文件中。这种就是静态库。</p></li><li><p>动态库（.so或.sa）：动态库在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用。使用动态库的优点是系统只需载入一次动态库，不同的程序可以得到内存中相同的动态库的副本，因此节省了很多内存。</p></li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#一般头文件或库文件的位置在：</span>
/usr/include <span class="token comment">#包括其子目录底下的include文件夹</span>
/usr/local/include <span class="token comment">#包括其子目录底下的include文件夹</span>
/usr/lib
/usr/local/lib
/lib
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></blockquote><h3 id="生成静态库" tabindex="-1"><a class="header-anchor" href="#生成静态库" aria-hidden="true">#</a> 生成静态库</h3><blockquote><p>生成.a文件，我们需要先生成.o文件。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>ar rcs lib_hello.a hello.o <span class="token comment">#在我的电脑报错了，MacBook Pro M1Pro 16寸，但还是生成了.a文件</span>
<span class="token comment">#在stackoverflow看到别人用 ar rcv lib_hello.a hello.o ，我尝试后没有报错，但最终运行的时候报了一个同样的错误。（下方见）</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>ar是gun归档工具，rcs表示replace and create，如果libhello之前存在，将创建新的libhello.a并将其替换。</p><p>然后就可以这样来使用静态库libhello.a</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>gcc <span class="token parameter variable">-Wall</span> main.c libhello.a <span class="token parameter variable">-o</span> main
<span class="token comment">#ld: warning: ignoring file lib_hello.a, building for macOS-arm64 but attempting to link #with file built for unknown-unsupported file format ( 0x21 0x3C 0x61 0x72 0x63 0x68 0x3E #0x0A 0x68 0x65 0x6C 0x6C 0x6F 0x2E 0x6F 0x20 )</span>
<span class="token comment">#Undefined symbols for architecture arm64:</span>
<span class="token comment">#  &quot;_printHello&quot;, referenced from:</span>
<span class="token comment">#      _main in main-c22d15.o</span>
<span class="token comment">#ld: symbol(s) not found for architecture arm64</span>
<span class="token comment">#clang: error: linker command failed with exit code 1 (use -v to see invocation)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>还有另外一种使用方式：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>gcc <span class="token parameter variable">-Wall</span> -L. main.c <span class="token parameter variable">-o</span> main <span class="token parameter variable">-lhello</span> <span class="token comment">#【lhello 是 libhello的缩写】</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其中 **-L.**表示库文件的位置在当前目录下，由于libhello.a是我们自己生成的，并存放在当前录下下，所以需要加上-L.选项。默认库文件是在系统的目录下进行搜索。同样的，-I.选项用于头文件的搜索。</p></blockquote><h3 id="生成共享库" tabindex="-1"><a class="header-anchor" href="#生成共享库" aria-hidden="true">#</a> 生成共享库</h3><blockquote><p>生成一个共享库，名称的规则是libxxx.so 。将 hello.o 生成为libhello.o 的命令为：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>gcc <span class="token parameter variable">-shared</span> <span class="token parameter variable">-fPIC</span> hello.o <span class="token parameter variable">-o</span> libhello.so
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>生成了共享库之后，可以这样来使用共享库：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>gcc <span class="token parameter variable">-Wall</span> main.o <span class="token parameter variable">-o</span> main -L. <span class="token parameter variable">-lhello</span>
<span class="token comment">#该命令与使用静态库的命令相同，但是在共享库与静态库共存的情况下，优先使用共享库。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>共享库有时候并不不在当前的目录下，为了让gcc能够找得到共享库，有下面几种方法：</p><ol><li>拷贝.so文件到系统共享库路径下，一般指/usr/lib</li><li>在~/.bash_profile文件中，配置LD_LIBRARY_PATH变量</li><li>配置/etc/ld.so.conf，配置完成后调用ldconfig更新ld.so.cache</li></ol></blockquote><p><strong>其中，shared选项表示生成共享库格式。fPIC表示产生位置无关码（position independent code），位置无关码表示它的运行、加载与内存位置无关，可以在任何内存地址进行加载。</strong></p></blockquote><h3 id="库的搜索路径" tabindex="-1"><a class="header-anchor" href="#库的搜索路径" aria-hidden="true">#</a> 库的搜索路径</h3><blockquote><p>库的搜索路径遵循几个搜索原则：</p><ul><li>从左到右搜索 -l指定的目录，如果在这些目录找不到那么gcc会从环境变量指定的目录查找。</li><li>头文件的环境变量是<strong>C_INCLUDE_PATH</strong>。</li><li>库的环境变量是<strong>LIBRARY_PATH</strong>。</li><li>如果还是找不到，那么会从系统指定的目录搜索。</li></ul></blockquote><h3 id="c语言中-include-和-的区别" tabindex="-1"><a class="header-anchor" href="#c语言中-include-和-的区别" aria-hidden="true">#</a> C语言中 #include &lt;&gt; 和 &quot;&quot; 的区别</h3><blockquote><ul><li>表示编译器只在系统默认目录或尖括号内的工作目录下搜索头文件，并不去用户的工作目录下寻找，所以一般尖括号用于包含标准库文件，如：#include &lt;stdio.h&gt;, #include&lt;stdlib.h&gt;</li><li>表示编译器先在用户的工作目录下搜索头文件，如果搜索不到则到系统默认目录下去寻找，所以双引号一般用于包含用户自己编写的头文件。如：#include &quot;student.h&quot; , #include &quot;XXXX.h&quot; 。</li></ul></blockquote>`,31),c=[i];function t(o,d){return e(),n("div",null,c)}const p=a(l,[["render",t],["__file","Makefile.html.vue"]]);export{p as default};
