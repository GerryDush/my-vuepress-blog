import{_ as t,o as d,c as r,a as C}from"./app-521e935c.js";const e={},s=C(`<h1 id="乱七八糟" tabindex="-1"><a class="header-anchor" href="#乱七八糟" aria-hidden="true">#</a> 乱七八糟</h1><h2 id="crc校验" tabindex="-1"><a class="header-anchor" href="#crc校验" aria-hidden="true">#</a> CRC校验</h2><h3 id="crc算法简介" tabindex="-1"><a class="header-anchor" href="#crc算法简介" aria-hidden="true">#</a> CRC算法简介</h3><p>循环冗余校验（Cyclic Redundancy check，CRC）是一种根据网络数据包或计算机文件等书记产生简短固定位数校验码的一种信道编码技术，主要用来检测或校验数据传输或者保存后可能出现的错误，它是利用除法以及余数的原理来做错误帧检测的。</p><p>CRC校验计算速度快，检错能力强，易于用编码器等硬件电路实现，从检错的正确率与速度成本等方面，都比奇偶校验方式具有优势，因而，CRC成为计算机信息通信领域最为普遍的校验方式，常见应用有以太网/USB通信，压缩解压，视频编码，图像存储，磁盘读写等。</p><h3 id="crc参数模型" tabindex="-1"><a class="header-anchor" href="#crc参数模型" aria-hidden="true">#</a> CRC参数模型</h3><p>一个完整的CRC参数模型应该包含一下信息：WIDTH, POLY, INIT, REFIN, REFOUT, XOROUT</p><ul><li><strong>NAME</strong>：参数模型名称</li><li><strong>WIDTH</strong>： 宽度，即生成的CRC数据宽度，如CRC-8，生成CRC为8位</li><li><strong>POLY</strong>：十六进制多项式，省略最高位1，如X^8+X^2+X+1,二进制为1 0000 0111。（为了简单，可能会省略最高位的1）</li><li><strong>INIT</strong>：CRC初始值，和WIDTH位宽一致。</li><li><strong>REFIN</strong>：true或者false，在进行计算前，原始数据是否翻转，eg：原始数据0x34 = 0011 0100如果REFIN为ture，进行反转之后为0010 1100 = 0x2c.</li><li><strong>REFOUT</strong>：true或者false，运算完成后，得到的CRC值是否进行翻转，如计算得到的CRC值为：0x97 = 1001 0111，如果REFOUT为ture，进行翻转后为1110 1001 = 0xE9</li><li><strong>XOROUT</strong>：计算结果与此参数进行异或运算后得到最终的CRC值，和WIDTH位宽一致。</li></ul><p><strong>CRC生成多项式转换为 POLY（十六进制多项式）</strong></p><p>如 INIT(CRC 初始值)为0x00 即 二进制为 0000 0000，CRC8生成多项式：x8 + x2 + x + 1</p><p>1 ：0000 0000 1</p><p>x ：0000 0001 1</p><p>x^2 ：0000 0011 1</p><p>x^8 ：1000 0011 1</p><p><strong>通常如果只给了一个多项式，其他的没有说明，则默认：INIT：0x00，REFIN=false，REFOUT=false，XOROUT=0x00</strong></p><p><strong>常用的21个标准CRC参数模型：</strong></p><table><thead><tr><th><strong>CRC算法名称</strong></th><th><strong>多项式公式</strong></th><th><strong>宽度</strong></th><th><strong>多项式</strong></th><th><strong>初始值</strong></th><th><strong>结果异或值</strong></th><th><strong>输入反转</strong></th><th><strong>输出反转</strong></th></tr></thead><tbody><tr><td>CRC-4/ITU</td><td>x4 + x + 1</td><td>4</td><td>03</td><td>00</td><td>00</td><td>true</td><td>true</td></tr><tr><td>CRC-5/EPC</td><td>x5 + x3 + 1</td><td>5</td><td>09</td><td>09</td><td>00</td><td>false</td><td>false</td></tr><tr><td>CRC-5/ITU</td><td>x5 + x4 + x2 + 1</td><td>5</td><td>15</td><td>00</td><td>00</td><td>true</td><td>true</td></tr><tr><td>CRC-5/USB</td><td>x5 + x2 + 1</td><td>5</td><td>05</td><td>1F</td><td>1F</td><td>true</td><td>true</td></tr><tr><td>CRC-6/ITU</td><td>x6 + x + 1</td><td>6</td><td>03</td><td>00</td><td>00</td><td>true</td><td>true</td></tr><tr><td>CRC-7/MMC</td><td>x7 + x3 + 1</td><td>7</td><td>09</td><td>00</td><td>00</td><td>false</td><td>false</td></tr><tr><td>CRC-8</td><td>x8 + x2 + x + 1</td><td>8</td><td>07</td><td>00</td><td>00</td><td>false</td><td>false</td></tr><tr><td>CRC-8/ITU</td><td>x8 + x2 + x + 1</td><td>8</td><td>07</td><td>00</td><td>55</td><td>false</td><td>false</td></tr><tr><td>CRC-8/ROHC</td><td>x8 + x2 + x + 1</td><td>8</td><td>07</td><td>FF</td><td>00</td><td>true</td><td>true</td></tr><tr><td>CRC-8/MAXIM</td><td>x8 + x5 + x4 + 1</td><td>8</td><td>31</td><td>00</td><td>00</td><td>true</td><td>true</td></tr><tr><td>CRC-16/IBM</td><td>x16 + x15 + x2 + 1</td><td>16</td><td>8005</td><td>0000</td><td>0000</td><td>true</td><td>true</td></tr><tr><td>CRC-16/MAXIM</td><td>x16 + x15 + x2 + 1</td><td>16</td><td>8005</td><td>0000</td><td>FFFF</td><td>true</td><td>true</td></tr><tr><td>CRC-16/USB</td><td>x16 + x15 + x2 + 1</td><td>16</td><td>8005</td><td>FFFF</td><td>FFFF</td><td>true</td><td>true</td></tr><tr><td>CRC-16/MODBUS</td><td>x16 + x15 + x2 + 1</td><td>16</td><td>8005</td><td>FFFF</td><td>0000</td><td>true</td><td>true</td></tr><tr><td>CRC-16/CCITT</td><td>x16 + x12 + x5 + 1</td><td>16</td><td>1021</td><td>0000</td><td>0000</td><td>true</td><td>true</td></tr><tr><td>CRC-16/CCITT-FALSE</td><td>x16 + x12 + x5 + 1</td><td>16</td><td>1021</td><td>FFFF</td><td>0000</td><td>false</td><td>false</td></tr><tr><td>CRC-16/X25</td><td>x16 + x12 + x5 + 1</td><td>16</td><td>1021</td><td>FFFF</td><td>FFFF</td><td>true</td><td>true</td></tr><tr><td>CRC-16/XMODEM</td><td>x16 + x12 + x5 + 1</td><td>16</td><td>1021</td><td>0000</td><td>0000</td><td>false</td><td>false</td></tr><tr><td>CRC-16/DNP</td><td>x16 + x13 + x12 + x11 + x10 + x8 + x6 + x5 + x2 + 1</td><td>16</td><td>3D65</td><td>0000</td><td>FFFF</td><td>true</td><td>true</td></tr><tr><td>CRC-32</td><td>x32 + x26 + x23 + x22 + x16 + x12 + x11 + x10 + x8 + x7 + x5 + x4 + x2 + x + 1</td><td>32</td><td>04C11DB7</td><td>FFFFFFFF</td><td>FFFFFFFF</td><td>true</td><td>true</td></tr><tr><td>CRC-32/MPEG-2</td><td>x32 + x26 + x23 + x22 + x16 + x12 + x11 + x10 + x8 + x7 + x5 + x4 + x2 + x + 1</td><td>32</td><td>04C11DB7</td><td>FFFFFFFF</td><td>00000000</td><td>false</td><td>false</td></tr></tbody></table><p>CRC校验在电子通信领域非常常用，可以说有数据处理的地方就有CRC校验：</p><p>举几个例子：</p><ul><li>美信（MAXIM）的芯片DS2401/DS18B20,都是使用的CRC-8/MAXIM模型</li><li>SD卡或MMC使用的是CRC-7/MMC模型</li><li>Modbus通信协议使用的是CRC-16/MODBUS参数模型</li><li>USB协议中使用的是CRC-5/USB和CRC-16/USB模型</li><li>STM32自带的硬件CRC计算模块使用的是CRC-32模型</li></ul><p>至于多项式的选择，初始值和异或值得选择，输入输出是否翻转，这就这几到一定得编码和数学知识了，感兴趣得朋友可以了解一下每个CRC模型个个参数得来源，至于每种参数模型得检错能力，重复率，需要专业的数学计算了，不在本文讨论的范围内。</p><p><strong>CRC计算</strong></p><p>好了，了解了CRC参数模型知识，下面手算一个CRC值，来了解CRC计算的原理。</p><p><em><strong>*问：原始数据0x34，使用CRC-8/MAXIN参数模型，求CRC值？*</strong></em></p><p>0x34 ：110100</p><p>CRC-8/MAXIN ：x8 + x5 + x4 + 1= 0x32 = 1 0011 0001= 0011 0001（忽略最高位1）</p><div class="language-assembly line-numbers-mode" data-ext="assembly"><pre class="language-assembly"><code>NAME 					CRC-8/MAXIN 	# 参数模型名称
WIDTH					8 						# 宽度，即生成的CRC数据宽度，如CRC-8，生成CRC为8位
POLY					1 0011 0001 	# 十六进制多项式
INIT					0x00					# CRC初始值,和WIDTH位宽一致
REFIN 				true					# 原始数据是否翻转
REFOUT 				true					# CRC值是否进行翻转
XOROUT  			0x00					# 计算结果与此参数进行异或运算后得到最终的CRC值，和WIDTH位宽一致
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><code>INIT = 0x00</code>，与 POLY 异或后，POLY保持不变</p></li><li><p><code>REFIN = true</code>，对原始数据翻转 <code>110100 -&gt; 0010 1100</code></p></li><li><p>原始数据左移 <code>WHIDTH</code> 位，<code>0010 1100 0000 0000 = 10 1100 0000 0000</code></p></li><li><p>把处理后的数据和多项式进行模2除法，求得余数</p></li></ul><p><img src="https://cxrs.oss-cn-shenzhen.aliyuncs.com/picture202302221045494.png" alt="image-20230222091018875"></p><ul><li><p>模2除法取余数低8位：1111 1011</p></li><li><p>模2除法的计算结果与<code>XOROUT</code> 参数进行异或运算：</p><p><code>1111 1011 xor 0000 0000 = 1111 1011</code></p></li><li><p><code>REFOUT = true</code> 再对计算结果翻转得到最终的CRC校验值：<code>11011111 = 0xDF</code></p></li><li><p><code>数据 + CRC：0010 1100 1101 1111 = 0x34DF</code>，相当于数据左移8位 + CRC</p></li></ul><p><strong>CRC校验</strong></p><p>按照上面CRC计算的结果，最终的数据帧：0011 0100 1101 1111 = 34DF，前8位0011 0100是原始数据，后8位1101 1111 是 CRC结果。</p><p>接收端的校验有两种方式：</p><ul><li>一种是和CRC计算一样，在本地把<strong>接收到的数据和CRC分离</strong>，然后在本地对数据进行CRC运算，得到的CRC值和接收到的CRC进行比较，如果一致，说明数据接收正确，如果不一致，说明数据有错误。</li><li>另一种方法是把整个数据帧进行CRC运算，因为是数据帧相当于把原始数据左移8位 加上 余数，如果直接对整个数据帧进行CRC运算（除以多项式），那么余数应该为0，如果不为0说明数据出错。</li></ul>`,34),x=[s];function l(n,i){return d(),r("div",null,x)}const o=t(e,[["render",l],["__file","乱七八糟.html.vue"]]);export{o as default};
